// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LzsCvDataProtoCpp.proto

#ifndef PROTOBUF_INCLUDED_LzsCvDataProtoCpp_2eproto
#define PROTOBUF_INCLUDED_LzsCvDataProtoCpp_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_LzsCvDataProtoCpp_2eproto 

namespace protobuf_LzsCvDataProtoCpp_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_LzsCvDataProtoCpp_2eproto
namespace Lazysplits {
namespace Proto {
namespace CvData {
class GameInfo;
class GameInfoDefaultTypeInternal;
extern GameInfoDefaultTypeInternal _GameInfo_default_instance_;
class GameInfo_TargetEntry;
class GameInfo_TargetEntryDefaultTypeInternal;
extern GameInfo_TargetEntryDefaultTypeInternal _GameInfo_TargetEntry_default_instance_;
class GameList;
class GameListDefaultTypeInternal;
extern GameListDefaultTypeInternal _GameList_default_instance_;
class GameList_GameEntry;
class GameList_GameEntryDefaultTypeInternal;
extern GameList_GameEntryDefaultTypeInternal _GameList_GameEntry_default_instance_;
class RGB;
class RGBDefaultTypeInternal;
extern RGBDefaultTypeInternal _RGB_default_instance_;
class TargetInfo;
class TargetInfoDefaultTypeInternal;
extern TargetInfoDefaultTypeInternal _TargetInfo_default_instance_;
class TargetInfo_WatchInfo;
class TargetInfo_WatchInfoDefaultTypeInternal;
extern TargetInfo_WatchInfoDefaultTypeInternal _TargetInfo_WatchInfo_default_instance_;
class TargetInfo_WatchInfo_WatchArea;
class TargetInfo_WatchInfo_WatchAreaDefaultTypeInternal;
extern TargetInfo_WatchInfo_WatchAreaDefaultTypeInternal _TargetInfo_WatchInfo_WatchArea_default_instance_;
class UScalar2d;
class UScalar2dDefaultTypeInternal;
extern UScalar2dDefaultTypeInternal _UScalar2d_default_instance_;
}  // namespace CvData
}  // namespace Proto
}  // namespace Lazysplits
namespace google {
namespace protobuf {
template<> ::Lazysplits::Proto::CvData::GameInfo* Arena::CreateMaybeMessage<::Lazysplits::Proto::CvData::GameInfo>(Arena*);
template<> ::Lazysplits::Proto::CvData::GameInfo_TargetEntry* Arena::CreateMaybeMessage<::Lazysplits::Proto::CvData::GameInfo_TargetEntry>(Arena*);
template<> ::Lazysplits::Proto::CvData::GameList* Arena::CreateMaybeMessage<::Lazysplits::Proto::CvData::GameList>(Arena*);
template<> ::Lazysplits::Proto::CvData::GameList_GameEntry* Arena::CreateMaybeMessage<::Lazysplits::Proto::CvData::GameList_GameEntry>(Arena*);
template<> ::Lazysplits::Proto::CvData::RGB* Arena::CreateMaybeMessage<::Lazysplits::Proto::CvData::RGB>(Arena*);
template<> ::Lazysplits::Proto::CvData::TargetInfo* Arena::CreateMaybeMessage<::Lazysplits::Proto::CvData::TargetInfo>(Arena*);
template<> ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo* Arena::CreateMaybeMessage<::Lazysplits::Proto::CvData::TargetInfo_WatchInfo>(Arena*);
template<> ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea* Arena::CreateMaybeMessage<::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea>(Arena*);
template<> ::Lazysplits::Proto::CvData::UScalar2d* Arena::CreateMaybeMessage<::Lazysplits::Proto::CvData::UScalar2d>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Lazysplits {
namespace Proto {
namespace CvData {

enum TargetType {
  TGT_UNUSED = 0,
  TGT_RESET = 1,
  TGT_START = 2,
  TGT_STANDARD = 3,
  TGT_GENERATOR = 4,
  TGT_END = 5,
  TargetType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TargetType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TargetType_IsValid(int value);
const TargetType TargetType_MIN = TGT_UNUSED;
const TargetType TargetType_MAX = TGT_END;
const int TargetType_ARRAYSIZE = TargetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TargetType_descriptor();
inline const ::std::string& TargetType_Name(TargetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TargetType_descriptor(), value);
}
inline bool TargetType_Parse(
    const ::std::string& name, TargetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TargetType>(
    TargetType_descriptor(), name, value);
}
enum WatchType {
  WT_UNUSED_WATCH = 0,
  WT_COLOR = 1,
  WT_IMAGE_STATIC = 2,
  WatchType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  WatchType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool WatchType_IsValid(int value);
const WatchType WatchType_MIN = WT_UNUSED_WATCH;
const WatchType WatchType_MAX = WT_IMAGE_STATIC;
const int WatchType_ARRAYSIZE = WatchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* WatchType_descriptor();
inline const ::std::string& WatchType_Name(WatchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    WatchType_descriptor(), value);
}
inline bool WatchType_Parse(
    const ::std::string& name, WatchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WatchType>(
    WatchType_descriptor(), name, value);
}
// ===================================================================

class UScalar2d : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.CvData.UScalar2d) */ {
 public:
  UScalar2d();
  virtual ~UScalar2d();

  UScalar2d(const UScalar2d& from);

  inline UScalar2d& operator=(const UScalar2d& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UScalar2d(UScalar2d&& from) noexcept
    : UScalar2d() {
    *this = ::std::move(from);
  }

  inline UScalar2d& operator=(UScalar2d&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UScalar2d& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UScalar2d* internal_default_instance() {
    return reinterpret_cast<const UScalar2d*>(
               &_UScalar2d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(UScalar2d* other);
  friend void swap(UScalar2d& a, UScalar2d& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UScalar2d* New() const final {
    return CreateMaybeMessage<UScalar2d>(NULL);
  }

  UScalar2d* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UScalar2d>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UScalar2d& from);
  void MergeFrom(const UScalar2d& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UScalar2d* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::uint32 x() const;
  void set_x(::google::protobuf::uint32 value);

  // uint32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::uint32 y() const;
  void set_y(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.CvData.UScalar2d)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RGB : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.CvData.RGB) */ {
 public:
  RGB();
  virtual ~RGB();

  RGB(const RGB& from);

  inline RGB& operator=(const RGB& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RGB(RGB&& from) noexcept
    : RGB() {
    *this = ::std::move(from);
  }

  inline RGB& operator=(RGB&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RGB& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RGB* internal_default_instance() {
    return reinterpret_cast<const RGB*>(
               &_RGB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RGB* other);
  friend void swap(RGB& a, RGB& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RGB* New() const final {
    return CreateMaybeMessage<RGB>(NULL);
  }

  RGB* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RGB>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RGB& from);
  void MergeFrom(const RGB& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RGB* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 R = 1;
  void clear_r();
  static const int kRFieldNumber = 1;
  ::google::protobuf::uint32 r() const;
  void set_r(::google::protobuf::uint32 value);

  // uint32 G = 2;
  void clear_g();
  static const int kGFieldNumber = 2;
  ::google::protobuf::uint32 g() const;
  void set_g(::google::protobuf::uint32 value);

  // uint32 B = 3;
  void clear_b();
  static const int kBFieldNumber = 3;
  ::google::protobuf::uint32 b() const;
  void set_b(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.CvData.RGB)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 g_;
  ::google::protobuf::uint32 b_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameList_GameEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.CvData.GameList.GameEntry) */ {
 public:
  GameList_GameEntry();
  virtual ~GameList_GameEntry();

  GameList_GameEntry(const GameList_GameEntry& from);

  inline GameList_GameEntry& operator=(const GameList_GameEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameList_GameEntry(GameList_GameEntry&& from) noexcept
    : GameList_GameEntry() {
    *this = ::std::move(from);
  }

  inline GameList_GameEntry& operator=(GameList_GameEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameList_GameEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameList_GameEntry* internal_default_instance() {
    return reinterpret_cast<const GameList_GameEntry*>(
               &_GameList_GameEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GameList_GameEntry* other);
  friend void swap(GameList_GameEntry& a, GameList_GameEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameList_GameEntry* New() const final {
    return CreateMaybeMessage<GameList_GameEntry>(NULL);
  }

  GameList_GameEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameList_GameEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameList_GameEntry& from);
  void MergeFrom(const GameList_GameEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameList_GameEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string relative_path = 2;
  void clear_relative_path();
  static const int kRelativePathFieldNumber = 2;
  const ::std::string& relative_path() const;
  void set_relative_path(const ::std::string& value);
  #if LANG_CXX11
  void set_relative_path(::std::string&& value);
  #endif
  void set_relative_path(const char* value);
  void set_relative_path(const char* value, size_t size);
  ::std::string* mutable_relative_path();
  ::std::string* release_relative_path();
  void set_allocated_relative_path(::std::string* relative_path);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.CvData.GameList.GameEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr relative_path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.CvData.GameList) */ {
 public:
  GameList();
  virtual ~GameList();

  GameList(const GameList& from);

  inline GameList& operator=(const GameList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameList(GameList&& from) noexcept
    : GameList() {
    *this = ::std::move(from);
  }

  inline GameList& operator=(GameList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameList* internal_default_instance() {
    return reinterpret_cast<const GameList*>(
               &_GameList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GameList* other);
  friend void swap(GameList& a, GameList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameList* New() const final {
    return CreateMaybeMessage<GameList>(NULL);
  }

  GameList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameList& from);
  void MergeFrom(const GameList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GameList_GameEntry GameEntry;

  // accessors -------------------------------------------------------

  // repeated .Lazysplits.Proto.CvData.GameList.GameEntry games = 1;
  int games_size() const;
  void clear_games();
  static const int kGamesFieldNumber = 1;
  ::Lazysplits::Proto::CvData::GameList_GameEntry* mutable_games(int index);
  ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::CvData::GameList_GameEntry >*
      mutable_games();
  const ::Lazysplits::Proto::CvData::GameList_GameEntry& games(int index) const;
  ::Lazysplits::Proto::CvData::GameList_GameEntry* add_games();
  const ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::CvData::GameList_GameEntry >&
      games() const;

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.CvData.GameList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::CvData::GameList_GameEntry > games_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameInfo_TargetEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.CvData.GameInfo.TargetEntry) */ {
 public:
  GameInfo_TargetEntry();
  virtual ~GameInfo_TargetEntry();

  GameInfo_TargetEntry(const GameInfo_TargetEntry& from);

  inline GameInfo_TargetEntry& operator=(const GameInfo_TargetEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameInfo_TargetEntry(GameInfo_TargetEntry&& from) noexcept
    : GameInfo_TargetEntry() {
    *this = ::std::move(from);
  }

  inline GameInfo_TargetEntry& operator=(GameInfo_TargetEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInfo_TargetEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameInfo_TargetEntry* internal_default_instance() {
    return reinterpret_cast<const GameInfo_TargetEntry*>(
               &_GameInfo_TargetEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GameInfo_TargetEntry* other);
  friend void swap(GameInfo_TargetEntry& a, GameInfo_TargetEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameInfo_TargetEntry* New() const final {
    return CreateMaybeMessage<GameInfo_TargetEntry>(NULL);
  }

  GameInfo_TargetEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameInfo_TargetEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameInfo_TargetEntry& from);
  void MergeFrom(const GameInfo_TargetEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameInfo_TargetEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string relative_path = 3;
  void clear_relative_path();
  static const int kRelativePathFieldNumber = 3;
  const ::std::string& relative_path() const;
  void set_relative_path(const ::std::string& value);
  #if LANG_CXX11
  void set_relative_path(::std::string&& value);
  #endif
  void set_relative_path(const char* value);
  void set_relative_path(const char* value, size_t size);
  ::std::string* mutable_relative_path();
  ::std::string* release_relative_path();
  void set_allocated_relative_path(::std::string* relative_path);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // .Lazysplits.Proto.CvData.TargetType type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::Lazysplits::Proto::CvData::TargetType type() const;
  void set_type(::Lazysplits::Proto::CvData::TargetType value);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.CvData.GameInfo.TargetEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr relative_path_;
  ::google::protobuf::int32 id_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.CvData.GameInfo) */ {
 public:
  GameInfo();
  virtual ~GameInfo();

  GameInfo(const GameInfo& from);

  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameInfo(GameInfo&& from) noexcept
    : GameInfo() {
    *this = ::std::move(from);
  }

  inline GameInfo& operator=(GameInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameInfo* internal_default_instance() {
    return reinterpret_cast<const GameInfo*>(
               &_GameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GameInfo* other);
  friend void swap(GameInfo& a, GameInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameInfo* New() const final {
    return CreateMaybeMessage<GameInfo>(NULL);
  }

  GameInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GameInfo_TargetEntry TargetEntry;

  // accessors -------------------------------------------------------

  // repeated .Lazysplits.Proto.CvData.GameInfo.TargetEntry targets = 2;
  int targets_size() const;
  void clear_targets();
  static const int kTargetsFieldNumber = 2;
  ::Lazysplits::Proto::CvData::GameInfo_TargetEntry* mutable_targets(int index);
  ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::CvData::GameInfo_TargetEntry >*
      mutable_targets();
  const ::Lazysplits::Proto::CvData::GameInfo_TargetEntry& targets(int index) const;
  ::Lazysplits::Proto::CvData::GameInfo_TargetEntry* add_targets();
  const ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::CvData::GameInfo_TargetEntry >&
      targets() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.CvData.GameInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::CvData::GameInfo_TargetEntry > targets_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TargetInfo_WatchInfo_WatchArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.WatchArea) */ {
 public:
  TargetInfo_WatchInfo_WatchArea();
  virtual ~TargetInfo_WatchInfo_WatchArea();

  TargetInfo_WatchInfo_WatchArea(const TargetInfo_WatchInfo_WatchArea& from);

  inline TargetInfo_WatchInfo_WatchArea& operator=(const TargetInfo_WatchInfo_WatchArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TargetInfo_WatchInfo_WatchArea(TargetInfo_WatchInfo_WatchArea&& from) noexcept
    : TargetInfo_WatchInfo_WatchArea() {
    *this = ::std::move(from);
  }

  inline TargetInfo_WatchInfo_WatchArea& operator=(TargetInfo_WatchInfo_WatchArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetInfo_WatchInfo_WatchArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TargetInfo_WatchInfo_WatchArea* internal_default_instance() {
    return reinterpret_cast<const TargetInfo_WatchInfo_WatchArea*>(
               &_TargetInfo_WatchInfo_WatchArea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TargetInfo_WatchInfo_WatchArea* other);
  friend void swap(TargetInfo_WatchInfo_WatchArea& a, TargetInfo_WatchInfo_WatchArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TargetInfo_WatchInfo_WatchArea* New() const final {
    return CreateMaybeMessage<TargetInfo_WatchInfo_WatchArea>(NULL);
  }

  TargetInfo_WatchInfo_WatchArea* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TargetInfo_WatchInfo_WatchArea>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TargetInfo_WatchInfo_WatchArea& from);
  void MergeFrom(const TargetInfo_WatchInfo_WatchArea& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetInfo_WatchInfo_WatchArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Lazysplits.Proto.CvData.UScalar2d loc = 1;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 1;
  private:
  const ::Lazysplits::Proto::CvData::UScalar2d& _internal_loc() const;
  public:
  const ::Lazysplits::Proto::CvData::UScalar2d& loc() const;
  ::Lazysplits::Proto::CvData::UScalar2d* release_loc();
  ::Lazysplits::Proto::CvData::UScalar2d* mutable_loc();
  void set_allocated_loc(::Lazysplits::Proto::CvData::UScalar2d* loc);

  // .Lazysplits.Proto.CvData.UScalar2d size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  private:
  const ::Lazysplits::Proto::CvData::UScalar2d& _internal_size() const;
  public:
  const ::Lazysplits::Proto::CvData::UScalar2d& size() const;
  ::Lazysplits::Proto::CvData::UScalar2d* release_size();
  ::Lazysplits::Proto::CvData::UScalar2d* mutable_size();
  void set_allocated_size(::Lazysplits::Proto::CvData::UScalar2d* size);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.WatchArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Lazysplits::Proto::CvData::UScalar2d* loc_;
  ::Lazysplits::Proto::CvData::UScalar2d* size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TargetInfo_WatchInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.CvData.TargetInfo.WatchInfo) */ {
 public:
  TargetInfo_WatchInfo();
  virtual ~TargetInfo_WatchInfo();

  TargetInfo_WatchInfo(const TargetInfo_WatchInfo& from);

  inline TargetInfo_WatchInfo& operator=(const TargetInfo_WatchInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TargetInfo_WatchInfo(TargetInfo_WatchInfo&& from) noexcept
    : TargetInfo_WatchInfo() {
    *this = ::std::move(from);
  }

  inline TargetInfo_WatchInfo& operator=(TargetInfo_WatchInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetInfo_WatchInfo& default_instance();

  enum WatchCvDataCase {
    kColor = 5,
    kImgRelativePath = 6,
    WATCH_CV_DATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TargetInfo_WatchInfo* internal_default_instance() {
    return reinterpret_cast<const TargetInfo_WatchInfo*>(
               &_TargetInfo_WatchInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(TargetInfo_WatchInfo* other);
  friend void swap(TargetInfo_WatchInfo& a, TargetInfo_WatchInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TargetInfo_WatchInfo* New() const final {
    return CreateMaybeMessage<TargetInfo_WatchInfo>(NULL);
  }

  TargetInfo_WatchInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TargetInfo_WatchInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TargetInfo_WatchInfo& from);
  void MergeFrom(const TargetInfo_WatchInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetInfo_WatchInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TargetInfo_WatchInfo_WatchArea WatchArea;

  // accessors -------------------------------------------------------

  // .Lazysplits.Proto.CvData.TargetInfo.WatchInfo.WatchArea area = 4;
  bool has_area() const;
  void clear_area();
  static const int kAreaFieldNumber = 4;
  private:
  const ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea& _internal_area() const;
  public:
  const ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea& area() const;
  ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea* release_area();
  ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea* mutable_area();
  void set_allocated_area(::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea* area);

  // uint32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // uint32 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // .Lazysplits.Proto.CvData.WatchType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::Lazysplits::Proto::CvData::WatchType type() const;
  void set_type(::Lazysplits::Proto::CvData::WatchType value);

  // .Lazysplits.Proto.CvData.RGB color = 5;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 5;
  private:
  const ::Lazysplits::Proto::CvData::RGB& _internal_color() const;
  public:
  const ::Lazysplits::Proto::CvData::RGB& color() const;
  ::Lazysplits::Proto::CvData::RGB* release_color();
  ::Lazysplits::Proto::CvData::RGB* mutable_color();
  void set_allocated_color(::Lazysplits::Proto::CvData::RGB* color);

  // string img_relative_path = 6;
  private:
  bool has_img_relative_path() const;
  public:
  void clear_img_relative_path();
  static const int kImgRelativePathFieldNumber = 6;
  const ::std::string& img_relative_path() const;
  void set_img_relative_path(const ::std::string& value);
  #if LANG_CXX11
  void set_img_relative_path(::std::string&& value);
  #endif
  void set_img_relative_path(const char* value);
  void set_img_relative_path(const char* value, size_t size);
  ::std::string* mutable_img_relative_path();
  ::std::string* release_img_relative_path();
  void set_allocated_img_relative_path(::std::string* img_relative_path);

  void clear_watch_cv_data();
  WatchCvDataCase watch_cv_data_case() const;
  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.CvData.TargetInfo.WatchInfo)
 private:
  void set_has_color();
  void set_has_img_relative_path();

  inline bool has_watch_cv_data() const;
  inline void clear_has_watch_cv_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea* area_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 index_;
  int type_;
  union WatchCvDataUnion {
    WatchCvDataUnion() {}
    ::Lazysplits::Proto::CvData::RGB* color_;
    ::google::protobuf::internal::ArenaStringPtr img_relative_path_;
  } watch_cv_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TargetInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.CvData.TargetInfo) */ {
 public:
  TargetInfo();
  virtual ~TargetInfo();

  TargetInfo(const TargetInfo& from);

  inline TargetInfo& operator=(const TargetInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TargetInfo(TargetInfo&& from) noexcept
    : TargetInfo() {
    *this = ::std::move(from);
  }

  inline TargetInfo& operator=(TargetInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TargetInfo* internal_default_instance() {
    return reinterpret_cast<const TargetInfo*>(
               &_TargetInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(TargetInfo* other);
  friend void swap(TargetInfo& a, TargetInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TargetInfo* New() const final {
    return CreateMaybeMessage<TargetInfo>(NULL);
  }

  TargetInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TargetInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TargetInfo& from);
  void MergeFrom(const TargetInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TargetInfo_WatchInfo WatchInfo;

  // accessors -------------------------------------------------------

  // repeated .Lazysplits.Proto.CvData.TargetInfo.WatchInfo watches = 5;
  int watches_size() const;
  void clear_watches();
  static const int kWatchesFieldNumber = 5;
  ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo* mutable_watches(int index);
  ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo >*
      mutable_watches();
  const ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo& watches(int index) const;
  ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo* add_watches();
  const ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo >&
      watches() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // .Lazysplits.Proto.CvData.TargetType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::Lazysplits::Proto::CvData::TargetType type() const;
  void set_type(::Lazysplits::Proto::CvData::TargetType value);

  // sint32 split_offset_ms = 4;
  void clear_split_offset_ms();
  static const int kSplitOffsetMsFieldNumber = 4;
  ::google::protobuf::int32 split_offset_ms() const;
  void set_split_offset_ms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.CvData.TargetInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo > watches_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 id_;
  int type_;
  ::google::protobuf::int32 split_offset_ms_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UScalar2d

// uint32 x = 1;
inline void UScalar2d::clear_x() {
  x_ = 0u;
}
inline ::google::protobuf::uint32 UScalar2d::x() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.UScalar2d.x)
  return x_;
}
inline void UScalar2d::set_x(::google::protobuf::uint32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.UScalar2d.x)
}

// uint32 y = 2;
inline void UScalar2d::clear_y() {
  y_ = 0u;
}
inline ::google::protobuf::uint32 UScalar2d::y() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.UScalar2d.y)
  return y_;
}
inline void UScalar2d::set_y(::google::protobuf::uint32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.UScalar2d.y)
}

// -------------------------------------------------------------------

// RGB

// uint32 R = 1;
inline void RGB::clear_r() {
  r_ = 0u;
}
inline ::google::protobuf::uint32 RGB::r() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.RGB.R)
  return r_;
}
inline void RGB::set_r(::google::protobuf::uint32 value) {
  
  r_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.RGB.R)
}

// uint32 G = 2;
inline void RGB::clear_g() {
  g_ = 0u;
}
inline ::google::protobuf::uint32 RGB::g() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.RGB.G)
  return g_;
}
inline void RGB::set_g(::google::protobuf::uint32 value) {
  
  g_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.RGB.G)
}

// uint32 B = 3;
inline void RGB::clear_b() {
  b_ = 0u;
}
inline ::google::protobuf::uint32 RGB::b() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.RGB.B)
  return b_;
}
inline void RGB::set_b(::google::protobuf::uint32 value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.RGB.B)
}

// -------------------------------------------------------------------

// GameList_GameEntry

// string name = 1;
inline void GameList_GameEntry::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameList_GameEntry::name() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.GameList.GameEntry.name)
  return name_.GetNoArena();
}
inline void GameList_GameEntry::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.GameList.GameEntry.name)
}
#if LANG_CXX11
inline void GameList_GameEntry::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.CvData.GameList.GameEntry.name)
}
#endif
inline void GameList_GameEntry::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.CvData.GameList.GameEntry.name)
}
inline void GameList_GameEntry::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.CvData.GameList.GameEntry.name)
}
inline ::std::string* GameList_GameEntry::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.CvData.GameList.GameEntry.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameList_GameEntry::release_name() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.CvData.GameList.GameEntry.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameList_GameEntry::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.CvData.GameList.GameEntry.name)
}

// string relative_path = 2;
inline void GameList_GameEntry::clear_relative_path() {
  relative_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameList_GameEntry::relative_path() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.GameList.GameEntry.relative_path)
  return relative_path_.GetNoArena();
}
inline void GameList_GameEntry::set_relative_path(const ::std::string& value) {
  
  relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.GameList.GameEntry.relative_path)
}
#if LANG_CXX11
inline void GameList_GameEntry::set_relative_path(::std::string&& value) {
  
  relative_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.CvData.GameList.GameEntry.relative_path)
}
#endif
inline void GameList_GameEntry::set_relative_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.CvData.GameList.GameEntry.relative_path)
}
inline void GameList_GameEntry::set_relative_path(const char* value, size_t size) {
  
  relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.CvData.GameList.GameEntry.relative_path)
}
inline ::std::string* GameList_GameEntry::mutable_relative_path() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.CvData.GameList.GameEntry.relative_path)
  return relative_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameList_GameEntry::release_relative_path() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.CvData.GameList.GameEntry.relative_path)
  
  return relative_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameList_GameEntry::set_allocated_relative_path(::std::string* relative_path) {
  if (relative_path != NULL) {
    
  } else {
    
  }
  relative_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), relative_path);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.CvData.GameList.GameEntry.relative_path)
}

// -------------------------------------------------------------------

// GameList

// repeated .Lazysplits.Proto.CvData.GameList.GameEntry games = 1;
inline int GameList::games_size() const {
  return games_.size();
}
inline void GameList::clear_games() {
  games_.Clear();
}
inline ::Lazysplits::Proto::CvData::GameList_GameEntry* GameList::mutable_games(int index) {
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.CvData.GameList.games)
  return games_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::CvData::GameList_GameEntry >*
GameList::mutable_games() {
  // @@protoc_insertion_point(field_mutable_list:Lazysplits.Proto.CvData.GameList.games)
  return &games_;
}
inline const ::Lazysplits::Proto::CvData::GameList_GameEntry& GameList::games(int index) const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.GameList.games)
  return games_.Get(index);
}
inline ::Lazysplits::Proto::CvData::GameList_GameEntry* GameList::add_games() {
  // @@protoc_insertion_point(field_add:Lazysplits.Proto.CvData.GameList.games)
  return games_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::CvData::GameList_GameEntry >&
GameList::games() const {
  // @@protoc_insertion_point(field_list:Lazysplits.Proto.CvData.GameList.games)
  return games_;
}

// -------------------------------------------------------------------

// GameInfo_TargetEntry

// int32 id = 1;
inline void GameInfo_TargetEntry::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 GameInfo_TargetEntry::id() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.GameInfo.TargetEntry.id)
  return id_;
}
inline void GameInfo_TargetEntry::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.GameInfo.TargetEntry.id)
}

// string name = 2;
inline void GameInfo_TargetEntry::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameInfo_TargetEntry::name() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.GameInfo.TargetEntry.name)
  return name_.GetNoArena();
}
inline void GameInfo_TargetEntry::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.GameInfo.TargetEntry.name)
}
#if LANG_CXX11
inline void GameInfo_TargetEntry::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.CvData.GameInfo.TargetEntry.name)
}
#endif
inline void GameInfo_TargetEntry::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.CvData.GameInfo.TargetEntry.name)
}
inline void GameInfo_TargetEntry::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.CvData.GameInfo.TargetEntry.name)
}
inline ::std::string* GameInfo_TargetEntry::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.CvData.GameInfo.TargetEntry.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameInfo_TargetEntry::release_name() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.CvData.GameInfo.TargetEntry.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameInfo_TargetEntry::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.CvData.GameInfo.TargetEntry.name)
}

// string relative_path = 3;
inline void GameInfo_TargetEntry::clear_relative_path() {
  relative_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameInfo_TargetEntry::relative_path() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.GameInfo.TargetEntry.relative_path)
  return relative_path_.GetNoArena();
}
inline void GameInfo_TargetEntry::set_relative_path(const ::std::string& value) {
  
  relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.GameInfo.TargetEntry.relative_path)
}
#if LANG_CXX11
inline void GameInfo_TargetEntry::set_relative_path(::std::string&& value) {
  
  relative_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.CvData.GameInfo.TargetEntry.relative_path)
}
#endif
inline void GameInfo_TargetEntry::set_relative_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.CvData.GameInfo.TargetEntry.relative_path)
}
inline void GameInfo_TargetEntry::set_relative_path(const char* value, size_t size) {
  
  relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.CvData.GameInfo.TargetEntry.relative_path)
}
inline ::std::string* GameInfo_TargetEntry::mutable_relative_path() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.CvData.GameInfo.TargetEntry.relative_path)
  return relative_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameInfo_TargetEntry::release_relative_path() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.CvData.GameInfo.TargetEntry.relative_path)
  
  return relative_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameInfo_TargetEntry::set_allocated_relative_path(::std::string* relative_path) {
  if (relative_path != NULL) {
    
  } else {
    
  }
  relative_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), relative_path);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.CvData.GameInfo.TargetEntry.relative_path)
}

// .Lazysplits.Proto.CvData.TargetType type = 4;
inline void GameInfo_TargetEntry::clear_type() {
  type_ = 0;
}
inline ::Lazysplits::Proto::CvData::TargetType GameInfo_TargetEntry::type() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.GameInfo.TargetEntry.type)
  return static_cast< ::Lazysplits::Proto::CvData::TargetType >(type_);
}
inline void GameInfo_TargetEntry::set_type(::Lazysplits::Proto::CvData::TargetType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.GameInfo.TargetEntry.type)
}

// -------------------------------------------------------------------

// GameInfo

// string name = 1;
inline void GameInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameInfo::name() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.GameInfo.name)
  return name_.GetNoArena();
}
inline void GameInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.GameInfo.name)
}
#if LANG_CXX11
inline void GameInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.CvData.GameInfo.name)
}
#endif
inline void GameInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.CvData.GameInfo.name)
}
inline void GameInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.CvData.GameInfo.name)
}
inline ::std::string* GameInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.CvData.GameInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameInfo::release_name() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.CvData.GameInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.CvData.GameInfo.name)
}

// repeated .Lazysplits.Proto.CvData.GameInfo.TargetEntry targets = 2;
inline int GameInfo::targets_size() const {
  return targets_.size();
}
inline void GameInfo::clear_targets() {
  targets_.Clear();
}
inline ::Lazysplits::Proto::CvData::GameInfo_TargetEntry* GameInfo::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.CvData.GameInfo.targets)
  return targets_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::CvData::GameInfo_TargetEntry >*
GameInfo::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:Lazysplits.Proto.CvData.GameInfo.targets)
  return &targets_;
}
inline const ::Lazysplits::Proto::CvData::GameInfo_TargetEntry& GameInfo::targets(int index) const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.GameInfo.targets)
  return targets_.Get(index);
}
inline ::Lazysplits::Proto::CvData::GameInfo_TargetEntry* GameInfo::add_targets() {
  // @@protoc_insertion_point(field_add:Lazysplits.Proto.CvData.GameInfo.targets)
  return targets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::CvData::GameInfo_TargetEntry >&
GameInfo::targets() const {
  // @@protoc_insertion_point(field_list:Lazysplits.Proto.CvData.GameInfo.targets)
  return targets_;
}

// -------------------------------------------------------------------

// TargetInfo_WatchInfo_WatchArea

// .Lazysplits.Proto.CvData.UScalar2d loc = 1;
inline bool TargetInfo_WatchInfo_WatchArea::has_loc() const {
  return this != internal_default_instance() && loc_ != NULL;
}
inline void TargetInfo_WatchInfo_WatchArea::clear_loc() {
  if (GetArenaNoVirtual() == NULL && loc_ != NULL) {
    delete loc_;
  }
  loc_ = NULL;
}
inline const ::Lazysplits::Proto::CvData::UScalar2d& TargetInfo_WatchInfo_WatchArea::_internal_loc() const {
  return *loc_;
}
inline const ::Lazysplits::Proto::CvData::UScalar2d& TargetInfo_WatchInfo_WatchArea::loc() const {
  const ::Lazysplits::Proto::CvData::UScalar2d* p = loc_;
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.WatchArea.loc)
  return p != NULL ? *p : *reinterpret_cast<const ::Lazysplits::Proto::CvData::UScalar2d*>(
      &::Lazysplits::Proto::CvData::_UScalar2d_default_instance_);
}
inline ::Lazysplits::Proto::CvData::UScalar2d* TargetInfo_WatchInfo_WatchArea::release_loc() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.WatchArea.loc)
  
  ::Lazysplits::Proto::CvData::UScalar2d* temp = loc_;
  loc_ = NULL;
  return temp;
}
inline ::Lazysplits::Proto::CvData::UScalar2d* TargetInfo_WatchInfo_WatchArea::mutable_loc() {
  
  if (loc_ == NULL) {
    auto* p = CreateMaybeMessage<::Lazysplits::Proto::CvData::UScalar2d>(GetArenaNoVirtual());
    loc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.WatchArea.loc)
  return loc_;
}
inline void TargetInfo_WatchInfo_WatchArea::set_allocated_loc(::Lazysplits::Proto::CvData::UScalar2d* loc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete loc_;
  }
  if (loc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      loc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, loc, submessage_arena);
    }
    
  } else {
    
  }
  loc_ = loc;
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.WatchArea.loc)
}

// .Lazysplits.Proto.CvData.UScalar2d size = 2;
inline bool TargetInfo_WatchInfo_WatchArea::has_size() const {
  return this != internal_default_instance() && size_ != NULL;
}
inline void TargetInfo_WatchInfo_WatchArea::clear_size() {
  if (GetArenaNoVirtual() == NULL && size_ != NULL) {
    delete size_;
  }
  size_ = NULL;
}
inline const ::Lazysplits::Proto::CvData::UScalar2d& TargetInfo_WatchInfo_WatchArea::_internal_size() const {
  return *size_;
}
inline const ::Lazysplits::Proto::CvData::UScalar2d& TargetInfo_WatchInfo_WatchArea::size() const {
  const ::Lazysplits::Proto::CvData::UScalar2d* p = size_;
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.WatchArea.size)
  return p != NULL ? *p : *reinterpret_cast<const ::Lazysplits::Proto::CvData::UScalar2d*>(
      &::Lazysplits::Proto::CvData::_UScalar2d_default_instance_);
}
inline ::Lazysplits::Proto::CvData::UScalar2d* TargetInfo_WatchInfo_WatchArea::release_size() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.WatchArea.size)
  
  ::Lazysplits::Proto::CvData::UScalar2d* temp = size_;
  size_ = NULL;
  return temp;
}
inline ::Lazysplits::Proto::CvData::UScalar2d* TargetInfo_WatchInfo_WatchArea::mutable_size() {
  
  if (size_ == NULL) {
    auto* p = CreateMaybeMessage<::Lazysplits::Proto::CvData::UScalar2d>(GetArenaNoVirtual());
    size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.WatchArea.size)
  return size_;
}
inline void TargetInfo_WatchInfo_WatchArea::set_allocated_size(::Lazysplits::Proto::CvData::UScalar2d* size) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete size_;
  }
  if (size) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      size = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.WatchArea.size)
}

// -------------------------------------------------------------------

// TargetInfo_WatchInfo

// uint32 id = 1;
inline void TargetInfo_WatchInfo::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 TargetInfo_WatchInfo::id() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.id)
  return id_;
}
inline void TargetInfo_WatchInfo::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.id)
}

// uint32 index = 2;
inline void TargetInfo_WatchInfo::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 TargetInfo_WatchInfo::index() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.index)
  return index_;
}
inline void TargetInfo_WatchInfo::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.index)
}

// .Lazysplits.Proto.CvData.WatchType type = 3;
inline void TargetInfo_WatchInfo::clear_type() {
  type_ = 0;
}
inline ::Lazysplits::Proto::CvData::WatchType TargetInfo_WatchInfo::type() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.type)
  return static_cast< ::Lazysplits::Proto::CvData::WatchType >(type_);
}
inline void TargetInfo_WatchInfo::set_type(::Lazysplits::Proto::CvData::WatchType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.type)
}

// .Lazysplits.Proto.CvData.TargetInfo.WatchInfo.WatchArea area = 4;
inline bool TargetInfo_WatchInfo::has_area() const {
  return this != internal_default_instance() && area_ != NULL;
}
inline void TargetInfo_WatchInfo::clear_area() {
  if (GetArenaNoVirtual() == NULL && area_ != NULL) {
    delete area_;
  }
  area_ = NULL;
}
inline const ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea& TargetInfo_WatchInfo::_internal_area() const {
  return *area_;
}
inline const ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea& TargetInfo_WatchInfo::area() const {
  const ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea* p = area_;
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.area)
  return p != NULL ? *p : *reinterpret_cast<const ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea*>(
      &::Lazysplits::Proto::CvData::_TargetInfo_WatchInfo_WatchArea_default_instance_);
}
inline ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea* TargetInfo_WatchInfo::release_area() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.area)
  
  ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea* temp = area_;
  area_ = NULL;
  return temp;
}
inline ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea* TargetInfo_WatchInfo::mutable_area() {
  
  if (area_ == NULL) {
    auto* p = CreateMaybeMessage<::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea>(GetArenaNoVirtual());
    area_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.area)
  return area_;
}
inline void TargetInfo_WatchInfo::set_allocated_area(::Lazysplits::Proto::CvData::TargetInfo_WatchInfo_WatchArea* area) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete area_;
  }
  if (area) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      area = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, area, submessage_arena);
    }
    
  } else {
    
  }
  area_ = area;
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.area)
}

// .Lazysplits.Proto.CvData.RGB color = 5;
inline bool TargetInfo_WatchInfo::has_color() const {
  return watch_cv_data_case() == kColor;
}
inline void TargetInfo_WatchInfo::set_has_color() {
  _oneof_case_[0] = kColor;
}
inline void TargetInfo_WatchInfo::clear_color() {
  if (has_color()) {
    delete watch_cv_data_.color_;
    clear_has_watch_cv_data();
  }
}
inline const ::Lazysplits::Proto::CvData::RGB& TargetInfo_WatchInfo::_internal_color() const {
  return *watch_cv_data_.color_;
}
inline ::Lazysplits::Proto::CvData::RGB* TargetInfo_WatchInfo::release_color() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.color)
  if (has_color()) {
    clear_has_watch_cv_data();
      ::Lazysplits::Proto::CvData::RGB* temp = watch_cv_data_.color_;
    watch_cv_data_.color_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Lazysplits::Proto::CvData::RGB& TargetInfo_WatchInfo::color() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.color)
  return has_color()
      ? *watch_cv_data_.color_
      : *reinterpret_cast< ::Lazysplits::Proto::CvData::RGB*>(&::Lazysplits::Proto::CvData::_RGB_default_instance_);
}
inline ::Lazysplits::Proto::CvData::RGB* TargetInfo_WatchInfo::mutable_color() {
  if (!has_color()) {
    clear_watch_cv_data();
    set_has_color();
    watch_cv_data_.color_ = CreateMaybeMessage< ::Lazysplits::Proto::CvData::RGB >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.color)
  return watch_cv_data_.color_;
}

// string img_relative_path = 6;
inline bool TargetInfo_WatchInfo::has_img_relative_path() const {
  return watch_cv_data_case() == kImgRelativePath;
}
inline void TargetInfo_WatchInfo::set_has_img_relative_path() {
  _oneof_case_[0] = kImgRelativePath;
}
inline void TargetInfo_WatchInfo::clear_img_relative_path() {
  if (has_img_relative_path()) {
    watch_cv_data_.img_relative_path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_watch_cv_data();
  }
}
inline const ::std::string& TargetInfo_WatchInfo::img_relative_path() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.img_relative_path)
  if (has_img_relative_path()) {
    return watch_cv_data_.img_relative_path_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TargetInfo_WatchInfo::set_img_relative_path(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.img_relative_path)
  if (!has_img_relative_path()) {
    clear_watch_cv_data();
    set_has_img_relative_path();
    watch_cv_data_.img_relative_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  watch_cv_data_.img_relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.img_relative_path)
}
#if LANG_CXX11
inline void TargetInfo_WatchInfo::set_img_relative_path(::std::string&& value) {
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.img_relative_path)
  if (!has_img_relative_path()) {
    clear_watch_cv_data();
    set_has_img_relative_path();
    watch_cv_data_.img_relative_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  watch_cv_data_.img_relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.img_relative_path)
}
#endif
inline void TargetInfo_WatchInfo::set_img_relative_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_img_relative_path()) {
    clear_watch_cv_data();
    set_has_img_relative_path();
    watch_cv_data_.img_relative_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  watch_cv_data_.img_relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.img_relative_path)
}
inline void TargetInfo_WatchInfo::set_img_relative_path(const char* value, size_t size) {
  if (!has_img_relative_path()) {
    clear_watch_cv_data();
    set_has_img_relative_path();
    watch_cv_data_.img_relative_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  watch_cv_data_.img_relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.img_relative_path)
}
inline ::std::string* TargetInfo_WatchInfo::mutable_img_relative_path() {
  if (!has_img_relative_path()) {
    clear_watch_cv_data();
    set_has_img_relative_path();
    watch_cv_data_.img_relative_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.img_relative_path)
  return watch_cv_data_.img_relative_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TargetInfo_WatchInfo::release_img_relative_path() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.img_relative_path)
  if (has_img_relative_path()) {
    clear_has_watch_cv_data();
    return watch_cv_data_.img_relative_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TargetInfo_WatchInfo::set_allocated_img_relative_path(::std::string* img_relative_path) {
  if (!has_img_relative_path()) {
    watch_cv_data_.img_relative_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_watch_cv_data();
  if (img_relative_path != NULL) {
    set_has_img_relative_path();
    watch_cv_data_.img_relative_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), img_relative_path);
  }
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.CvData.TargetInfo.WatchInfo.img_relative_path)
}

inline bool TargetInfo_WatchInfo::has_watch_cv_data() const {
  return watch_cv_data_case() != WATCH_CV_DATA_NOT_SET;
}
inline void TargetInfo_WatchInfo::clear_has_watch_cv_data() {
  _oneof_case_[0] = WATCH_CV_DATA_NOT_SET;
}
inline TargetInfo_WatchInfo::WatchCvDataCase TargetInfo_WatchInfo::watch_cv_data_case() const {
  return TargetInfo_WatchInfo::WatchCvDataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TargetInfo

// int32 id = 1;
inline void TargetInfo::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 TargetInfo::id() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.TargetInfo.id)
  return id_;
}
inline void TargetInfo::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.TargetInfo.id)
}

// string name = 2;
inline void TargetInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TargetInfo::name() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.TargetInfo.name)
  return name_.GetNoArena();
}
inline void TargetInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.TargetInfo.name)
}
#if LANG_CXX11
inline void TargetInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.CvData.TargetInfo.name)
}
#endif
inline void TargetInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.CvData.TargetInfo.name)
}
inline void TargetInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.CvData.TargetInfo.name)
}
inline ::std::string* TargetInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.CvData.TargetInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TargetInfo::release_name() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.CvData.TargetInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TargetInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.CvData.TargetInfo.name)
}

// .Lazysplits.Proto.CvData.TargetType type = 3;
inline void TargetInfo::clear_type() {
  type_ = 0;
}
inline ::Lazysplits::Proto::CvData::TargetType TargetInfo::type() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.TargetInfo.type)
  return static_cast< ::Lazysplits::Proto::CvData::TargetType >(type_);
}
inline void TargetInfo::set_type(::Lazysplits::Proto::CvData::TargetType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.TargetInfo.type)
}

// sint32 split_offset_ms = 4;
inline void TargetInfo::clear_split_offset_ms() {
  split_offset_ms_ = 0;
}
inline ::google::protobuf::int32 TargetInfo::split_offset_ms() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.TargetInfo.split_offset_ms)
  return split_offset_ms_;
}
inline void TargetInfo::set_split_offset_ms(::google::protobuf::int32 value) {
  
  split_offset_ms_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.CvData.TargetInfo.split_offset_ms)
}

// repeated .Lazysplits.Proto.CvData.TargetInfo.WatchInfo watches = 5;
inline int TargetInfo::watches_size() const {
  return watches_.size();
}
inline void TargetInfo::clear_watches() {
  watches_.Clear();
}
inline ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo* TargetInfo::mutable_watches(int index) {
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.CvData.TargetInfo.watches)
  return watches_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo >*
TargetInfo::mutable_watches() {
  // @@protoc_insertion_point(field_mutable_list:Lazysplits.Proto.CvData.TargetInfo.watches)
  return &watches_;
}
inline const ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo& TargetInfo::watches(int index) const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.CvData.TargetInfo.watches)
  return watches_.Get(index);
}
inline ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo* TargetInfo::add_watches() {
  // @@protoc_insertion_point(field_add:Lazysplits.Proto.CvData.TargetInfo.watches)
  return watches_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::CvData::TargetInfo_WatchInfo >&
TargetInfo::watches() const {
  // @@protoc_insertion_point(field_list:Lazysplits.Proto.CvData.TargetInfo.watches)
  return watches_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace CvData
}  // namespace Proto
}  // namespace Lazysplits

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Lazysplits::Proto::CvData::TargetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Lazysplits::Proto::CvData::TargetType>() {
  return ::Lazysplits::Proto::CvData::TargetType_descriptor();
}
template <> struct is_proto_enum< ::Lazysplits::Proto::CvData::WatchType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Lazysplits::Proto::CvData::WatchType>() {
  return ::Lazysplits::Proto::CvData::WatchType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_LzsCvDataProtoCpp_2eproto
