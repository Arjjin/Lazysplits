// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LzsCvDataProtoCpp.proto

#ifndef PROTOBUF_INCLUDED_LzsCvDataProtoCpp_2eproto
#define PROTOBUF_INCLUDED_LzsCvDataProtoCpp_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_LzsCvDataProtoCpp_2eproto 

namespace protobuf_LzsCvDataProtoCpp_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_LzsCvDataProtoCpp_2eproto
namespace Lazysplits {
namespace Proto {
class GameInfo;
class GameInfoDefaultTypeInternal;
extern GameInfoDefaultTypeInternal _GameInfo_default_instance_;
class GameInfo_TargetEntry;
class GameInfo_TargetEntryDefaultTypeInternal;
extern GameInfo_TargetEntryDefaultTypeInternal _GameInfo_TargetEntry_default_instance_;
class GameList;
class GameListDefaultTypeInternal;
extern GameListDefaultTypeInternal _GameList_default_instance_;
class GameList_GameEntry;
class GameList_GameEntryDefaultTypeInternal;
extern GameList_GameEntryDefaultTypeInternal _GameList_GameEntry_default_instance_;
class RGBColor;
class RGBColorDefaultTypeInternal;
extern RGBColorDefaultTypeInternal _RGBColor_default_instance_;
class TargetInfo;
class TargetInfoDefaultTypeInternal;
extern TargetInfoDefaultTypeInternal _TargetInfo_default_instance_;
class TargetInfo_WatchEntry;
class TargetInfo_WatchEntryDefaultTypeInternal;
extern TargetInfo_WatchEntryDefaultTypeInternal _TargetInfo_WatchEntry_default_instance_;
class UScalar2d;
class UScalar2dDefaultTypeInternal;
extern UScalar2dDefaultTypeInternal _UScalar2d_default_instance_;
class WatchInfo;
class WatchInfoDefaultTypeInternal;
extern WatchInfoDefaultTypeInternal _WatchInfo_default_instance_;
class WatchInfo_AdditionalOffsetEntry;
class WatchInfo_AdditionalOffsetEntryDefaultTypeInternal;
extern WatchInfo_AdditionalOffsetEntryDefaultTypeInternal _WatchInfo_AdditionalOffsetEntry_default_instance_;
class WatchInfo_CharacterEntry;
class WatchInfo_CharacterEntryDefaultTypeInternal;
extern WatchInfo_CharacterEntryDefaultTypeInternal _WatchInfo_CharacterEntry_default_instance_;
class WatchInfo_WatchArea;
class WatchInfo_WatchAreaDefaultTypeInternal;
extern WatchInfo_WatchAreaDefaultTypeInternal _WatchInfo_WatchArea_default_instance_;
}  // namespace Proto
}  // namespace Lazysplits
namespace google {
namespace protobuf {
template<> ::Lazysplits::Proto::GameInfo* Arena::CreateMaybeMessage<::Lazysplits::Proto::GameInfo>(Arena*);
template<> ::Lazysplits::Proto::GameInfo_TargetEntry* Arena::CreateMaybeMessage<::Lazysplits::Proto::GameInfo_TargetEntry>(Arena*);
template<> ::Lazysplits::Proto::GameList* Arena::CreateMaybeMessage<::Lazysplits::Proto::GameList>(Arena*);
template<> ::Lazysplits::Proto::GameList_GameEntry* Arena::CreateMaybeMessage<::Lazysplits::Proto::GameList_GameEntry>(Arena*);
template<> ::Lazysplits::Proto::RGBColor* Arena::CreateMaybeMessage<::Lazysplits::Proto::RGBColor>(Arena*);
template<> ::Lazysplits::Proto::TargetInfo* Arena::CreateMaybeMessage<::Lazysplits::Proto::TargetInfo>(Arena*);
template<> ::Lazysplits::Proto::TargetInfo_WatchEntry* Arena::CreateMaybeMessage<::Lazysplits::Proto::TargetInfo_WatchEntry>(Arena*);
template<> ::Lazysplits::Proto::UScalar2d* Arena::CreateMaybeMessage<::Lazysplits::Proto::UScalar2d>(Arena*);
template<> ::Lazysplits::Proto::WatchInfo* Arena::CreateMaybeMessage<::Lazysplits::Proto::WatchInfo>(Arena*);
template<> ::Lazysplits::Proto::WatchInfo_AdditionalOffsetEntry* Arena::CreateMaybeMessage<::Lazysplits::Proto::WatchInfo_AdditionalOffsetEntry>(Arena*);
template<> ::Lazysplits::Proto::WatchInfo_CharacterEntry* Arena::CreateMaybeMessage<::Lazysplits::Proto::WatchInfo_CharacterEntry>(Arena*);
template<> ::Lazysplits::Proto::WatchInfo_WatchArea* Arena::CreateMaybeMessage<::Lazysplits::Proto::WatchInfo_WatchArea>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Lazysplits {
namespace Proto {

enum TargetType {
  TGT_UNUSED = 0,
  TGT_RESET = 1,
  TGT_START = 2,
  TGT_STANDARD = 3,
  TGT_END = 4,
  TargetType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TargetType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TargetType_IsValid(int value);
const TargetType TargetType_MIN = TGT_UNUSED;
const TargetType TargetType_MAX = TGT_END;
const int TargetType_ARRAYSIZE = TargetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TargetType_descriptor();
inline const ::std::string& TargetType_Name(TargetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TargetType_descriptor(), value);
}
inline bool TargetType_Parse(
    const ::std::string& name, TargetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TargetType>(
    TargetType_descriptor(), name, value);
}
enum WatchType {
  WT_UNUSED = 0,
  WT_COLOR = 1,
  WT_IMAGE_STATIC = 2,
  WT_CHARACTER_SET = 3,
  WatchType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  WatchType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool WatchType_IsValid(int value);
const WatchType WatchType_MIN = WT_UNUSED;
const WatchType WatchType_MAX = WT_CHARACTER_SET;
const int WatchType_ARRAYSIZE = WatchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* WatchType_descriptor();
inline const ::std::string& WatchType_Name(WatchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    WatchType_descriptor(), value);
}
inline bool WatchType_Parse(
    const ::std::string& name, WatchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WatchType>(
    WatchType_descriptor(), name, value);
}
enum CharacterJustify {
  CHARACTER_JUSTIFY_UNUSED = 0,
  CHARACTER_JUSTIFY_LEFT = 1,
  CHARACTER_JUSTIFY_RIGHT = 2,
  CharacterJustify_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CharacterJustify_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CharacterJustify_IsValid(int value);
const CharacterJustify CharacterJustify_MIN = CHARACTER_JUSTIFY_UNUSED;
const CharacterJustify CharacterJustify_MAX = CHARACTER_JUSTIFY_RIGHT;
const int CharacterJustify_ARRAYSIZE = CharacterJustify_MAX + 1;

const ::google::protobuf::EnumDescriptor* CharacterJustify_descriptor();
inline const ::std::string& CharacterJustify_Name(CharacterJustify value) {
  return ::google::protobuf::internal::NameOfEnum(
    CharacterJustify_descriptor(), value);
}
inline bool CharacterJustify_Parse(
    const ::std::string& name, CharacterJustify* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CharacterJustify>(
    CharacterJustify_descriptor(), name, value);
}
enum CharacterZOrder {
  CHARACTER_Z_UNUSED = 0,
  CHARACTER_Z_LEFT_TO_RIGHT = 1,
  CHARACTER_Z_RIGHT_TO_LEFT = 2,
  CharacterZOrder_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CharacterZOrder_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CharacterZOrder_IsValid(int value);
const CharacterZOrder CharacterZOrder_MIN = CHARACTER_Z_UNUSED;
const CharacterZOrder CharacterZOrder_MAX = CHARACTER_Z_RIGHT_TO_LEFT;
const int CharacterZOrder_ARRAYSIZE = CharacterZOrder_MAX + 1;

const ::google::protobuf::EnumDescriptor* CharacterZOrder_descriptor();
inline const ::std::string& CharacterZOrder_Name(CharacterZOrder value) {
  return ::google::protobuf::internal::NameOfEnum(
    CharacterZOrder_descriptor(), value);
}
inline bool CharacterZOrder_Parse(
    const ::std::string& name, CharacterZOrder* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CharacterZOrder>(
    CharacterZOrder_descriptor(), name, value);
}
// ===================================================================

class UScalar2d : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.UScalar2d) */ {
 public:
  UScalar2d();
  virtual ~UScalar2d();

  UScalar2d(const UScalar2d& from);

  inline UScalar2d& operator=(const UScalar2d& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UScalar2d(UScalar2d&& from) noexcept
    : UScalar2d() {
    *this = ::std::move(from);
  }

  inline UScalar2d& operator=(UScalar2d&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UScalar2d& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UScalar2d* internal_default_instance() {
    return reinterpret_cast<const UScalar2d*>(
               &_UScalar2d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(UScalar2d* other);
  friend void swap(UScalar2d& a, UScalar2d& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UScalar2d* New() const final {
    return CreateMaybeMessage<UScalar2d>(NULL);
  }

  UScalar2d* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UScalar2d>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UScalar2d& from);
  void MergeFrom(const UScalar2d& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UScalar2d* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // sint32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // sint32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.UScalar2d)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RGBColor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.RGBColor) */ {
 public:
  RGBColor();
  virtual ~RGBColor();

  RGBColor(const RGBColor& from);

  inline RGBColor& operator=(const RGBColor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RGBColor(RGBColor&& from) noexcept
    : RGBColor() {
    *this = ::std::move(from);
  }

  inline RGBColor& operator=(RGBColor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RGBColor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RGBColor* internal_default_instance() {
    return reinterpret_cast<const RGBColor*>(
               &_RGBColor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RGBColor* other);
  friend void swap(RGBColor& a, RGBColor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RGBColor* New() const final {
    return CreateMaybeMessage<RGBColor>(NULL);
  }

  RGBColor* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RGBColor>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RGBColor& from);
  void MergeFrom(const RGBColor& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RGBColor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 R = 1;
  void clear_r();
  static const int kRFieldNumber = 1;
  ::google::protobuf::uint32 r() const;
  void set_r(::google::protobuf::uint32 value);

  // uint32 G = 2;
  void clear_g();
  static const int kGFieldNumber = 2;
  ::google::protobuf::uint32 g() const;
  void set_g(::google::protobuf::uint32 value);

  // uint32 B = 3;
  void clear_b();
  static const int kBFieldNumber = 3;
  ::google::protobuf::uint32 b() const;
  void set_b(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.RGBColor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 g_;
  ::google::protobuf::uint32 b_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameList_GameEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.GameList.GameEntry) */ {
 public:
  GameList_GameEntry();
  virtual ~GameList_GameEntry();

  GameList_GameEntry(const GameList_GameEntry& from);

  inline GameList_GameEntry& operator=(const GameList_GameEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameList_GameEntry(GameList_GameEntry&& from) noexcept
    : GameList_GameEntry() {
    *this = ::std::move(from);
  }

  inline GameList_GameEntry& operator=(GameList_GameEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameList_GameEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameList_GameEntry* internal_default_instance() {
    return reinterpret_cast<const GameList_GameEntry*>(
               &_GameList_GameEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GameList_GameEntry* other);
  friend void swap(GameList_GameEntry& a, GameList_GameEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameList_GameEntry* New() const final {
    return CreateMaybeMessage<GameList_GameEntry>(NULL);
  }

  GameList_GameEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameList_GameEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameList_GameEntry& from);
  void MergeFrom(const GameList_GameEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameList_GameEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string relative_path = 2;
  void clear_relative_path();
  static const int kRelativePathFieldNumber = 2;
  const ::std::string& relative_path() const;
  void set_relative_path(const ::std::string& value);
  #if LANG_CXX11
  void set_relative_path(::std::string&& value);
  #endif
  void set_relative_path(const char* value);
  void set_relative_path(const char* value, size_t size);
  ::std::string* mutable_relative_path();
  ::std::string* release_relative_path();
  void set_allocated_relative_path(::std::string* relative_path);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.GameList.GameEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr relative_path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.GameList) */ {
 public:
  GameList();
  virtual ~GameList();

  GameList(const GameList& from);

  inline GameList& operator=(const GameList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameList(GameList&& from) noexcept
    : GameList() {
    *this = ::std::move(from);
  }

  inline GameList& operator=(GameList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameList* internal_default_instance() {
    return reinterpret_cast<const GameList*>(
               &_GameList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GameList* other);
  friend void swap(GameList& a, GameList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameList* New() const final {
    return CreateMaybeMessage<GameList>(NULL);
  }

  GameList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameList& from);
  void MergeFrom(const GameList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GameList_GameEntry GameEntry;

  // accessors -------------------------------------------------------

  // repeated .Lazysplits.Proto.GameList.GameEntry games = 1;
  int games_size() const;
  void clear_games();
  static const int kGamesFieldNumber = 1;
  ::Lazysplits::Proto::GameList_GameEntry* mutable_games(int index);
  ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::GameList_GameEntry >*
      mutable_games();
  const ::Lazysplits::Proto::GameList_GameEntry& games(int index) const;
  ::Lazysplits::Proto::GameList_GameEntry* add_games();
  const ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::GameList_GameEntry >&
      games() const;

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.GameList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::GameList_GameEntry > games_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameInfo_TargetEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.GameInfo.TargetEntry) */ {
 public:
  GameInfo_TargetEntry();
  virtual ~GameInfo_TargetEntry();

  GameInfo_TargetEntry(const GameInfo_TargetEntry& from);

  inline GameInfo_TargetEntry& operator=(const GameInfo_TargetEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameInfo_TargetEntry(GameInfo_TargetEntry&& from) noexcept
    : GameInfo_TargetEntry() {
    *this = ::std::move(from);
  }

  inline GameInfo_TargetEntry& operator=(GameInfo_TargetEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInfo_TargetEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameInfo_TargetEntry* internal_default_instance() {
    return reinterpret_cast<const GameInfo_TargetEntry*>(
               &_GameInfo_TargetEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GameInfo_TargetEntry* other);
  friend void swap(GameInfo_TargetEntry& a, GameInfo_TargetEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameInfo_TargetEntry* New() const final {
    return CreateMaybeMessage<GameInfo_TargetEntry>(NULL);
  }

  GameInfo_TargetEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameInfo_TargetEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameInfo_TargetEntry& from);
  void MergeFrom(const GameInfo_TargetEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameInfo_TargetEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string relative_path = 2;
  void clear_relative_path();
  static const int kRelativePathFieldNumber = 2;
  const ::std::string& relative_path() const;
  void set_relative_path(const ::std::string& value);
  #if LANG_CXX11
  void set_relative_path(::std::string&& value);
  #endif
  void set_relative_path(const char* value);
  void set_relative_path(const char* value, size_t size);
  ::std::string* mutable_relative_path();
  ::std::string* release_relative_path();
  void set_allocated_relative_path(::std::string* relative_path);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.GameInfo.TargetEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr relative_path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.GameInfo) */ {
 public:
  GameInfo();
  virtual ~GameInfo();

  GameInfo(const GameInfo& from);

  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameInfo(GameInfo&& from) noexcept
    : GameInfo() {
    *this = ::std::move(from);
  }

  inline GameInfo& operator=(GameInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameInfo* internal_default_instance() {
    return reinterpret_cast<const GameInfo*>(
               &_GameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GameInfo* other);
  friend void swap(GameInfo& a, GameInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameInfo* New() const final {
    return CreateMaybeMessage<GameInfo>(NULL);
  }

  GameInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GameInfo_TargetEntry TargetEntry;

  // accessors -------------------------------------------------------

  // repeated .Lazysplits.Proto.GameInfo.TargetEntry targets = 2;
  int targets_size() const;
  void clear_targets();
  static const int kTargetsFieldNumber = 2;
  ::Lazysplits::Proto::GameInfo_TargetEntry* mutable_targets(int index);
  ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::GameInfo_TargetEntry >*
      mutable_targets();
  const ::Lazysplits::Proto::GameInfo_TargetEntry& targets(int index) const;
  ::Lazysplits::Proto::GameInfo_TargetEntry* add_targets();
  const ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::GameInfo_TargetEntry >&
      targets() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.GameInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::GameInfo_TargetEntry > targets_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TargetInfo_WatchEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.TargetInfo.WatchEntry) */ {
 public:
  TargetInfo_WatchEntry();
  virtual ~TargetInfo_WatchEntry();

  TargetInfo_WatchEntry(const TargetInfo_WatchEntry& from);

  inline TargetInfo_WatchEntry& operator=(const TargetInfo_WatchEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TargetInfo_WatchEntry(TargetInfo_WatchEntry&& from) noexcept
    : TargetInfo_WatchEntry() {
    *this = ::std::move(from);
  }

  inline TargetInfo_WatchEntry& operator=(TargetInfo_WatchEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetInfo_WatchEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TargetInfo_WatchEntry* internal_default_instance() {
    return reinterpret_cast<const TargetInfo_WatchEntry*>(
               &_TargetInfo_WatchEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TargetInfo_WatchEntry* other);
  friend void swap(TargetInfo_WatchEntry& a, TargetInfo_WatchEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TargetInfo_WatchEntry* New() const final {
    return CreateMaybeMessage<TargetInfo_WatchEntry>(NULL);
  }

  TargetInfo_WatchEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TargetInfo_WatchEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TargetInfo_WatchEntry& from);
  void MergeFrom(const TargetInfo_WatchEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetInfo_WatchEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string relative_path = 2;
  void clear_relative_path();
  static const int kRelativePathFieldNumber = 2;
  const ::std::string& relative_path() const;
  void set_relative_path(const ::std::string& value);
  #if LANG_CXX11
  void set_relative_path(::std::string&& value);
  #endif
  void set_relative_path(const char* value);
  void set_relative_path(const char* value, size_t size);
  ::std::string* mutable_relative_path();
  ::std::string* release_relative_path();
  void set_allocated_relative_path(::std::string* relative_path);

  // uint32 index = 3;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.TargetInfo.WatchEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr relative_path_;
  ::google::protobuf::uint32 index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TargetInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.TargetInfo) */ {
 public:
  TargetInfo();
  virtual ~TargetInfo();

  TargetInfo(const TargetInfo& from);

  inline TargetInfo& operator=(const TargetInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TargetInfo(TargetInfo&& from) noexcept
    : TargetInfo() {
    *this = ::std::move(from);
  }

  inline TargetInfo& operator=(TargetInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TargetInfo* internal_default_instance() {
    return reinterpret_cast<const TargetInfo*>(
               &_TargetInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(TargetInfo* other);
  friend void swap(TargetInfo& a, TargetInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TargetInfo* New() const final {
    return CreateMaybeMessage<TargetInfo>(NULL);
  }

  TargetInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TargetInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TargetInfo& from);
  void MergeFrom(const TargetInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TargetInfo_WatchEntry WatchEntry;

  // accessors -------------------------------------------------------

  // repeated .Lazysplits.Proto.TargetInfo.WatchEntry watches = 4;
  int watches_size() const;
  void clear_watches();
  static const int kWatchesFieldNumber = 4;
  ::Lazysplits::Proto::TargetInfo_WatchEntry* mutable_watches(int index);
  ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::TargetInfo_WatchEntry >*
      mutable_watches();
  const ::Lazysplits::Proto::TargetInfo_WatchEntry& watches(int index) const;
  ::Lazysplits::Proto::TargetInfo_WatchEntry* add_watches();
  const ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::TargetInfo_WatchEntry >&
      watches() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Lazysplits.Proto.TargetType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::Lazysplits::Proto::TargetType type() const;
  void set_type(::Lazysplits::Proto::TargetType value);

  // sint32 split_offset_ms = 3;
  void clear_split_offset_ms();
  static const int kSplitOffsetMsFieldNumber = 3;
  ::google::protobuf::int32 split_offset_ms() const;
  void set_split_offset_ms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.TargetInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::TargetInfo_WatchEntry > watches_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int type_;
  ::google::protobuf::int32 split_offset_ms_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WatchInfo_WatchArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.WatchInfo.WatchArea) */ {
 public:
  WatchInfo_WatchArea();
  virtual ~WatchInfo_WatchArea();

  WatchInfo_WatchArea(const WatchInfo_WatchArea& from);

  inline WatchInfo_WatchArea& operator=(const WatchInfo_WatchArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WatchInfo_WatchArea(WatchInfo_WatchArea&& from) noexcept
    : WatchInfo_WatchArea() {
    *this = ::std::move(from);
  }

  inline WatchInfo_WatchArea& operator=(WatchInfo_WatchArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WatchInfo_WatchArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WatchInfo_WatchArea* internal_default_instance() {
    return reinterpret_cast<const WatchInfo_WatchArea*>(
               &_WatchInfo_WatchArea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(WatchInfo_WatchArea* other);
  friend void swap(WatchInfo_WatchArea& a, WatchInfo_WatchArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WatchInfo_WatchArea* New() const final {
    return CreateMaybeMessage<WatchInfo_WatchArea>(NULL);
  }

  WatchInfo_WatchArea* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WatchInfo_WatchArea>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WatchInfo_WatchArea& from);
  void MergeFrom(const WatchInfo_WatchArea& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchInfo_WatchArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Lazysplits.Proto.UScalar2d loc = 1;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 1;
  private:
  const ::Lazysplits::Proto::UScalar2d& _internal_loc() const;
  public:
  const ::Lazysplits::Proto::UScalar2d& loc() const;
  ::Lazysplits::Proto::UScalar2d* release_loc();
  ::Lazysplits::Proto::UScalar2d* mutable_loc();
  void set_allocated_loc(::Lazysplits::Proto::UScalar2d* loc);

  // .Lazysplits.Proto.UScalar2d size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  private:
  const ::Lazysplits::Proto::UScalar2d& _internal_size() const;
  public:
  const ::Lazysplits::Proto::UScalar2d& size() const;
  ::Lazysplits::Proto::UScalar2d* release_size();
  ::Lazysplits::Proto::UScalar2d* mutable_size();
  void set_allocated_size(::Lazysplits::Proto::UScalar2d* size);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.WatchInfo.WatchArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Lazysplits::Proto::UScalar2d* loc_;
  ::Lazysplits::Proto::UScalar2d* size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WatchInfo_CharacterEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.WatchInfo.CharacterEntry) */ {
 public:
  WatchInfo_CharacterEntry();
  virtual ~WatchInfo_CharacterEntry();

  WatchInfo_CharacterEntry(const WatchInfo_CharacterEntry& from);

  inline WatchInfo_CharacterEntry& operator=(const WatchInfo_CharacterEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WatchInfo_CharacterEntry(WatchInfo_CharacterEntry&& from) noexcept
    : WatchInfo_CharacterEntry() {
    *this = ::std::move(from);
  }

  inline WatchInfo_CharacterEntry& operator=(WatchInfo_CharacterEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WatchInfo_CharacterEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WatchInfo_CharacterEntry* internal_default_instance() {
    return reinterpret_cast<const WatchInfo_CharacterEntry*>(
               &_WatchInfo_CharacterEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(WatchInfo_CharacterEntry* other);
  friend void swap(WatchInfo_CharacterEntry& a, WatchInfo_CharacterEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WatchInfo_CharacterEntry* New() const final {
    return CreateMaybeMessage<WatchInfo_CharacterEntry>(NULL);
  }

  WatchInfo_CharacterEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WatchInfo_CharacterEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WatchInfo_CharacterEntry& from);
  void MergeFrom(const WatchInfo_CharacterEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchInfo_CharacterEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string character_val = 2;
  void clear_character_val();
  static const int kCharacterValFieldNumber = 2;
  const ::std::string& character_val() const;
  void set_character_val(const ::std::string& value);
  #if LANG_CXX11
  void set_character_val(::std::string&& value);
  #endif
  void set_character_val(const char* value);
  void set_character_val(const char* value, size_t size);
  ::std::string* mutable_character_val();
  ::std::string* release_character_val();
  void set_allocated_character_val(::std::string* character_val);

  // uint32 character_index = 1;
  void clear_character_index();
  static const int kCharacterIndexFieldNumber = 1;
  ::google::protobuf::uint32 character_index() const;
  void set_character_index(::google::protobuf::uint32 value);

  // sint32 x_padding = 3;
  void clear_x_padding();
  static const int kXPaddingFieldNumber = 3;
  ::google::protobuf::int32 x_padding() const;
  void set_x_padding(::google::protobuf::int32 value);

  // sint32 y_padding = 4;
  void clear_y_padding();
  static const int kYPaddingFieldNumber = 4;
  ::google::protobuf::int32 y_padding() const;
  void set_y_padding(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.WatchInfo.CharacterEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr character_val_;
  ::google::protobuf::uint32 character_index_;
  ::google::protobuf::int32 x_padding_;
  ::google::protobuf::int32 y_padding_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WatchInfo_AdditionalOffsetEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.WatchInfo.AdditionalOffsetEntry) */ {
 public:
  WatchInfo_AdditionalOffsetEntry();
  virtual ~WatchInfo_AdditionalOffsetEntry();

  WatchInfo_AdditionalOffsetEntry(const WatchInfo_AdditionalOffsetEntry& from);

  inline WatchInfo_AdditionalOffsetEntry& operator=(const WatchInfo_AdditionalOffsetEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WatchInfo_AdditionalOffsetEntry(WatchInfo_AdditionalOffsetEntry&& from) noexcept
    : WatchInfo_AdditionalOffsetEntry() {
    *this = ::std::move(from);
  }

  inline WatchInfo_AdditionalOffsetEntry& operator=(WatchInfo_AdditionalOffsetEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WatchInfo_AdditionalOffsetEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WatchInfo_AdditionalOffsetEntry* internal_default_instance() {
    return reinterpret_cast<const WatchInfo_AdditionalOffsetEntry*>(
               &_WatchInfo_AdditionalOffsetEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(WatchInfo_AdditionalOffsetEntry* other);
  friend void swap(WatchInfo_AdditionalOffsetEntry& a, WatchInfo_AdditionalOffsetEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WatchInfo_AdditionalOffsetEntry* New() const final {
    return CreateMaybeMessage<WatchInfo_AdditionalOffsetEntry>(NULL);
  }

  WatchInfo_AdditionalOffsetEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WatchInfo_AdditionalOffsetEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WatchInfo_AdditionalOffsetEntry& from);
  void MergeFrom(const WatchInfo_AdditionalOffsetEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchInfo_AdditionalOffsetEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Lazysplits.Proto.UScalar2d offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  private:
  const ::Lazysplits::Proto::UScalar2d& _internal_offset() const;
  public:
  const ::Lazysplits::Proto::UScalar2d& offset() const;
  ::Lazysplits::Proto::UScalar2d* release_offset();
  ::Lazysplits::Proto::UScalar2d* mutable_offset();
  void set_allocated_offset(::Lazysplits::Proto::UScalar2d* offset);

  // uint32 character_length_threshold = 1;
  void clear_character_length_threshold();
  static const int kCharacterLengthThresholdFieldNumber = 1;
  ::google::protobuf::uint32 character_length_threshold() const;
  void set_character_length_threshold(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.WatchInfo.AdditionalOffsetEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Lazysplits::Proto::UScalar2d* offset_;
  ::google::protobuf::uint32 character_length_threshold_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WatchInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Lazysplits.Proto.WatchInfo) */ {
 public:
  WatchInfo();
  virtual ~WatchInfo();

  WatchInfo(const WatchInfo& from);

  inline WatchInfo& operator=(const WatchInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WatchInfo(WatchInfo&& from) noexcept
    : WatchInfo() {
    *this = ::std::move(from);
  }

  inline WatchInfo& operator=(WatchInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WatchInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WatchInfo* internal_default_instance() {
    return reinterpret_cast<const WatchInfo*>(
               &_WatchInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(WatchInfo* other);
  friend void swap(WatchInfo& a, WatchInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WatchInfo* New() const final {
    return CreateMaybeMessage<WatchInfo>(NULL);
  }

  WatchInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WatchInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WatchInfo& from);
  void MergeFrom(const WatchInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WatchInfo_WatchArea WatchArea;
  typedef WatchInfo_CharacterEntry CharacterEntry;
  typedef WatchInfo_AdditionalOffsetEntry AdditionalOffsetEntry;

  // accessors -------------------------------------------------------

  // repeated .Lazysplits.Proto.WatchInfo.CharacterEntry characters = 9;
  int characters_size() const;
  void clear_characters();
  static const int kCharactersFieldNumber = 9;
  ::Lazysplits::Proto::WatchInfo_CharacterEntry* mutable_characters(int index);
  ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::WatchInfo_CharacterEntry >*
      mutable_characters();
  const ::Lazysplits::Proto::WatchInfo_CharacterEntry& characters(int index) const;
  ::Lazysplits::Proto::WatchInfo_CharacterEntry* add_characters();
  const ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::WatchInfo_CharacterEntry >&
      characters() const;

  // repeated .Lazysplits.Proto.WatchInfo.AdditionalOffsetEntry additional_offset = 10;
  int additional_offset_size() const;
  void clear_additional_offset();
  static const int kAdditionalOffsetFieldNumber = 10;
  ::Lazysplits::Proto::WatchInfo_AdditionalOffsetEntry* mutable_additional_offset(int index);
  ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::WatchInfo_AdditionalOffsetEntry >*
      mutable_additional_offset();
  const ::Lazysplits::Proto::WatchInfo_AdditionalOffsetEntry& additional_offset(int index) const;
  ::Lazysplits::Proto::WatchInfo_AdditionalOffsetEntry* add_additional_offset();
  const ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::WatchInfo_AdditionalOffsetEntry >&
      additional_offset() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string img_relative_path = 6;
  void clear_img_relative_path();
  static const int kImgRelativePathFieldNumber = 6;
  const ::std::string& img_relative_path() const;
  void set_img_relative_path(const ::std::string& value);
  #if LANG_CXX11
  void set_img_relative_path(::std::string&& value);
  #endif
  void set_img_relative_path(const char* value);
  void set_img_relative_path(const char* value, size_t size);
  ::std::string* mutable_img_relative_path();
  ::std::string* release_img_relative_path();
  void set_allocated_img_relative_path(::std::string* img_relative_path);

  // .Lazysplits.Proto.UScalar2d base_dimensions = 3;
  bool has_base_dimensions() const;
  void clear_base_dimensions();
  static const int kBaseDimensionsFieldNumber = 3;
  private:
  const ::Lazysplits::Proto::UScalar2d& _internal_base_dimensions() const;
  public:
  const ::Lazysplits::Proto::UScalar2d& base_dimensions() const;
  ::Lazysplits::Proto::UScalar2d* release_base_dimensions();
  ::Lazysplits::Proto::UScalar2d* mutable_base_dimensions();
  void set_allocated_base_dimensions(::Lazysplits::Proto::UScalar2d* base_dimensions);

  // .Lazysplits.Proto.WatchInfo.WatchArea area = 4;
  bool has_area() const;
  void clear_area();
  static const int kAreaFieldNumber = 4;
  private:
  const ::Lazysplits::Proto::WatchInfo_WatchArea& _internal_area() const;
  public:
  const ::Lazysplits::Proto::WatchInfo_WatchArea& area() const;
  ::Lazysplits::Proto::WatchInfo_WatchArea* release_area();
  ::Lazysplits::Proto::WatchInfo_WatchArea* mutable_area();
  void set_allocated_area(::Lazysplits::Proto::WatchInfo_WatchArea* area);

  // .Lazysplits.Proto.RGBColor color = 5;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 5;
  private:
  const ::Lazysplits::Proto::RGBColor& _internal_color() const;
  public:
  const ::Lazysplits::Proto::RGBColor& color() const;
  ::Lazysplits::Proto::RGBColor* release_color();
  ::Lazysplits::Proto::RGBColor* mutable_color();
  void set_allocated_color(::Lazysplits::Proto::RGBColor* color);

  // .Lazysplits.Proto.WatchType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::Lazysplits::Proto::WatchType type() const;
  void set_type(::Lazysplits::Proto::WatchType value);

  // .Lazysplits.Proto.CharacterJustify character_justify = 7;
  void clear_character_justify();
  static const int kCharacterJustifyFieldNumber = 7;
  ::Lazysplits::Proto::CharacterJustify character_justify() const;
  void set_character_justify(::Lazysplits::Proto::CharacterJustify value);

  // .Lazysplits.Proto.CharacterZOrder character_z_order = 8;
  void clear_character_z_order();
  static const int kCharacterZOrderFieldNumber = 8;
  ::Lazysplits::Proto::CharacterZOrder character_z_order() const;
  void set_character_z_order(::Lazysplits::Proto::CharacterZOrder value);

  // uint32 additional_area_padding = 11;
  void clear_additional_area_padding();
  static const int kAdditionalAreaPaddingFieldNumber = 11;
  ::google::protobuf::uint32 additional_area_padding() const;
  void set_additional_area_padding(::google::protobuf::uint32 value);

  // float base_threshold = 12;
  void clear_base_threshold();
  static const int kBaseThresholdFieldNumber = 12;
  float base_threshold() const;
  void set_base_threshold(float value);

  // @@protoc_insertion_point(class_scope:Lazysplits.Proto.WatchInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::WatchInfo_CharacterEntry > characters_;
  ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::WatchInfo_AdditionalOffsetEntry > additional_offset_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr img_relative_path_;
  ::Lazysplits::Proto::UScalar2d* base_dimensions_;
  ::Lazysplits::Proto::WatchInfo_WatchArea* area_;
  ::Lazysplits::Proto::RGBColor* color_;
  int type_;
  int character_justify_;
  int character_z_order_;
  ::google::protobuf::uint32 additional_area_padding_;
  float base_threshold_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LzsCvDataProtoCpp_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UScalar2d

// sint32 x = 1;
inline void UScalar2d::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 UScalar2d::x() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.UScalar2d.x)
  return x_;
}
inline void UScalar2d::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.UScalar2d.x)
}

// sint32 y = 2;
inline void UScalar2d::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 UScalar2d::y() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.UScalar2d.y)
  return y_;
}
inline void UScalar2d::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.UScalar2d.y)
}

// -------------------------------------------------------------------

// RGBColor

// uint32 R = 1;
inline void RGBColor::clear_r() {
  r_ = 0u;
}
inline ::google::protobuf::uint32 RGBColor::r() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.RGBColor.R)
  return r_;
}
inline void RGBColor::set_r(::google::protobuf::uint32 value) {
  
  r_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.RGBColor.R)
}

// uint32 G = 2;
inline void RGBColor::clear_g() {
  g_ = 0u;
}
inline ::google::protobuf::uint32 RGBColor::g() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.RGBColor.G)
  return g_;
}
inline void RGBColor::set_g(::google::protobuf::uint32 value) {
  
  g_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.RGBColor.G)
}

// uint32 B = 3;
inline void RGBColor::clear_b() {
  b_ = 0u;
}
inline ::google::protobuf::uint32 RGBColor::b() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.RGBColor.B)
  return b_;
}
inline void RGBColor::set_b(::google::protobuf::uint32 value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.RGBColor.B)
}

// -------------------------------------------------------------------

// GameList_GameEntry

// string name = 1;
inline void GameList_GameEntry::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameList_GameEntry::name() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.GameList.GameEntry.name)
  return name_.GetNoArena();
}
inline void GameList_GameEntry::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.GameList.GameEntry.name)
}
#if LANG_CXX11
inline void GameList_GameEntry::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.GameList.GameEntry.name)
}
#endif
inline void GameList_GameEntry::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.GameList.GameEntry.name)
}
inline void GameList_GameEntry::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.GameList.GameEntry.name)
}
inline ::std::string* GameList_GameEntry::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.GameList.GameEntry.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameList_GameEntry::release_name() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.GameList.GameEntry.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameList_GameEntry::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.GameList.GameEntry.name)
}

// string relative_path = 2;
inline void GameList_GameEntry::clear_relative_path() {
  relative_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameList_GameEntry::relative_path() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.GameList.GameEntry.relative_path)
  return relative_path_.GetNoArena();
}
inline void GameList_GameEntry::set_relative_path(const ::std::string& value) {
  
  relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.GameList.GameEntry.relative_path)
}
#if LANG_CXX11
inline void GameList_GameEntry::set_relative_path(::std::string&& value) {
  
  relative_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.GameList.GameEntry.relative_path)
}
#endif
inline void GameList_GameEntry::set_relative_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.GameList.GameEntry.relative_path)
}
inline void GameList_GameEntry::set_relative_path(const char* value, size_t size) {
  
  relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.GameList.GameEntry.relative_path)
}
inline ::std::string* GameList_GameEntry::mutable_relative_path() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.GameList.GameEntry.relative_path)
  return relative_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameList_GameEntry::release_relative_path() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.GameList.GameEntry.relative_path)
  
  return relative_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameList_GameEntry::set_allocated_relative_path(::std::string* relative_path) {
  if (relative_path != NULL) {
    
  } else {
    
  }
  relative_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), relative_path);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.GameList.GameEntry.relative_path)
}

// -------------------------------------------------------------------

// GameList

// repeated .Lazysplits.Proto.GameList.GameEntry games = 1;
inline int GameList::games_size() const {
  return games_.size();
}
inline void GameList::clear_games() {
  games_.Clear();
}
inline ::Lazysplits::Proto::GameList_GameEntry* GameList::mutable_games(int index) {
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.GameList.games)
  return games_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::GameList_GameEntry >*
GameList::mutable_games() {
  // @@protoc_insertion_point(field_mutable_list:Lazysplits.Proto.GameList.games)
  return &games_;
}
inline const ::Lazysplits::Proto::GameList_GameEntry& GameList::games(int index) const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.GameList.games)
  return games_.Get(index);
}
inline ::Lazysplits::Proto::GameList_GameEntry* GameList::add_games() {
  // @@protoc_insertion_point(field_add:Lazysplits.Proto.GameList.games)
  return games_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::GameList_GameEntry >&
GameList::games() const {
  // @@protoc_insertion_point(field_list:Lazysplits.Proto.GameList.games)
  return games_;
}

// -------------------------------------------------------------------

// GameInfo_TargetEntry

// string name = 1;
inline void GameInfo_TargetEntry::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameInfo_TargetEntry::name() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.GameInfo.TargetEntry.name)
  return name_.GetNoArena();
}
inline void GameInfo_TargetEntry::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.GameInfo.TargetEntry.name)
}
#if LANG_CXX11
inline void GameInfo_TargetEntry::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.GameInfo.TargetEntry.name)
}
#endif
inline void GameInfo_TargetEntry::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.GameInfo.TargetEntry.name)
}
inline void GameInfo_TargetEntry::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.GameInfo.TargetEntry.name)
}
inline ::std::string* GameInfo_TargetEntry::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.GameInfo.TargetEntry.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameInfo_TargetEntry::release_name() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.GameInfo.TargetEntry.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameInfo_TargetEntry::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.GameInfo.TargetEntry.name)
}

// string relative_path = 2;
inline void GameInfo_TargetEntry::clear_relative_path() {
  relative_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameInfo_TargetEntry::relative_path() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.GameInfo.TargetEntry.relative_path)
  return relative_path_.GetNoArena();
}
inline void GameInfo_TargetEntry::set_relative_path(const ::std::string& value) {
  
  relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.GameInfo.TargetEntry.relative_path)
}
#if LANG_CXX11
inline void GameInfo_TargetEntry::set_relative_path(::std::string&& value) {
  
  relative_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.GameInfo.TargetEntry.relative_path)
}
#endif
inline void GameInfo_TargetEntry::set_relative_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.GameInfo.TargetEntry.relative_path)
}
inline void GameInfo_TargetEntry::set_relative_path(const char* value, size_t size) {
  
  relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.GameInfo.TargetEntry.relative_path)
}
inline ::std::string* GameInfo_TargetEntry::mutable_relative_path() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.GameInfo.TargetEntry.relative_path)
  return relative_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameInfo_TargetEntry::release_relative_path() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.GameInfo.TargetEntry.relative_path)
  
  return relative_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameInfo_TargetEntry::set_allocated_relative_path(::std::string* relative_path) {
  if (relative_path != NULL) {
    
  } else {
    
  }
  relative_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), relative_path);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.GameInfo.TargetEntry.relative_path)
}

// -------------------------------------------------------------------

// GameInfo

// string name = 1;
inline void GameInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameInfo::name() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.GameInfo.name)
  return name_.GetNoArena();
}
inline void GameInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.GameInfo.name)
}
#if LANG_CXX11
inline void GameInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.GameInfo.name)
}
#endif
inline void GameInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.GameInfo.name)
}
inline void GameInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.GameInfo.name)
}
inline ::std::string* GameInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.GameInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameInfo::release_name() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.GameInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.GameInfo.name)
}

// repeated .Lazysplits.Proto.GameInfo.TargetEntry targets = 2;
inline int GameInfo::targets_size() const {
  return targets_.size();
}
inline void GameInfo::clear_targets() {
  targets_.Clear();
}
inline ::Lazysplits::Proto::GameInfo_TargetEntry* GameInfo::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.GameInfo.targets)
  return targets_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::GameInfo_TargetEntry >*
GameInfo::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:Lazysplits.Proto.GameInfo.targets)
  return &targets_;
}
inline const ::Lazysplits::Proto::GameInfo_TargetEntry& GameInfo::targets(int index) const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.GameInfo.targets)
  return targets_.Get(index);
}
inline ::Lazysplits::Proto::GameInfo_TargetEntry* GameInfo::add_targets() {
  // @@protoc_insertion_point(field_add:Lazysplits.Proto.GameInfo.targets)
  return targets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::GameInfo_TargetEntry >&
GameInfo::targets() const {
  // @@protoc_insertion_point(field_list:Lazysplits.Proto.GameInfo.targets)
  return targets_;
}

// -------------------------------------------------------------------

// TargetInfo_WatchEntry

// string name = 1;
inline void TargetInfo_WatchEntry::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TargetInfo_WatchEntry::name() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.TargetInfo.WatchEntry.name)
  return name_.GetNoArena();
}
inline void TargetInfo_WatchEntry::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.TargetInfo.WatchEntry.name)
}
#if LANG_CXX11
inline void TargetInfo_WatchEntry::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.TargetInfo.WatchEntry.name)
}
#endif
inline void TargetInfo_WatchEntry::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.TargetInfo.WatchEntry.name)
}
inline void TargetInfo_WatchEntry::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.TargetInfo.WatchEntry.name)
}
inline ::std::string* TargetInfo_WatchEntry::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.TargetInfo.WatchEntry.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TargetInfo_WatchEntry::release_name() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.TargetInfo.WatchEntry.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TargetInfo_WatchEntry::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.TargetInfo.WatchEntry.name)
}

// string relative_path = 2;
inline void TargetInfo_WatchEntry::clear_relative_path() {
  relative_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TargetInfo_WatchEntry::relative_path() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.TargetInfo.WatchEntry.relative_path)
  return relative_path_.GetNoArena();
}
inline void TargetInfo_WatchEntry::set_relative_path(const ::std::string& value) {
  
  relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.TargetInfo.WatchEntry.relative_path)
}
#if LANG_CXX11
inline void TargetInfo_WatchEntry::set_relative_path(::std::string&& value) {
  
  relative_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.TargetInfo.WatchEntry.relative_path)
}
#endif
inline void TargetInfo_WatchEntry::set_relative_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.TargetInfo.WatchEntry.relative_path)
}
inline void TargetInfo_WatchEntry::set_relative_path(const char* value, size_t size) {
  
  relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.TargetInfo.WatchEntry.relative_path)
}
inline ::std::string* TargetInfo_WatchEntry::mutable_relative_path() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.TargetInfo.WatchEntry.relative_path)
  return relative_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TargetInfo_WatchEntry::release_relative_path() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.TargetInfo.WatchEntry.relative_path)
  
  return relative_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TargetInfo_WatchEntry::set_allocated_relative_path(::std::string* relative_path) {
  if (relative_path != NULL) {
    
  } else {
    
  }
  relative_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), relative_path);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.TargetInfo.WatchEntry.relative_path)
}

// uint32 index = 3;
inline void TargetInfo_WatchEntry::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 TargetInfo_WatchEntry::index() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.TargetInfo.WatchEntry.index)
  return index_;
}
inline void TargetInfo_WatchEntry::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.TargetInfo.WatchEntry.index)
}

// -------------------------------------------------------------------

// TargetInfo

// string name = 1;
inline void TargetInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TargetInfo::name() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.TargetInfo.name)
  return name_.GetNoArena();
}
inline void TargetInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.TargetInfo.name)
}
#if LANG_CXX11
inline void TargetInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.TargetInfo.name)
}
#endif
inline void TargetInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.TargetInfo.name)
}
inline void TargetInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.TargetInfo.name)
}
inline ::std::string* TargetInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.TargetInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TargetInfo::release_name() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.TargetInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TargetInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.TargetInfo.name)
}

// .Lazysplits.Proto.TargetType type = 2;
inline void TargetInfo::clear_type() {
  type_ = 0;
}
inline ::Lazysplits::Proto::TargetType TargetInfo::type() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.TargetInfo.type)
  return static_cast< ::Lazysplits::Proto::TargetType >(type_);
}
inline void TargetInfo::set_type(::Lazysplits::Proto::TargetType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.TargetInfo.type)
}

// sint32 split_offset_ms = 3;
inline void TargetInfo::clear_split_offset_ms() {
  split_offset_ms_ = 0;
}
inline ::google::protobuf::int32 TargetInfo::split_offset_ms() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.TargetInfo.split_offset_ms)
  return split_offset_ms_;
}
inline void TargetInfo::set_split_offset_ms(::google::protobuf::int32 value) {
  
  split_offset_ms_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.TargetInfo.split_offset_ms)
}

// repeated .Lazysplits.Proto.TargetInfo.WatchEntry watches = 4;
inline int TargetInfo::watches_size() const {
  return watches_.size();
}
inline void TargetInfo::clear_watches() {
  watches_.Clear();
}
inline ::Lazysplits::Proto::TargetInfo_WatchEntry* TargetInfo::mutable_watches(int index) {
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.TargetInfo.watches)
  return watches_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::TargetInfo_WatchEntry >*
TargetInfo::mutable_watches() {
  // @@protoc_insertion_point(field_mutable_list:Lazysplits.Proto.TargetInfo.watches)
  return &watches_;
}
inline const ::Lazysplits::Proto::TargetInfo_WatchEntry& TargetInfo::watches(int index) const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.TargetInfo.watches)
  return watches_.Get(index);
}
inline ::Lazysplits::Proto::TargetInfo_WatchEntry* TargetInfo::add_watches() {
  // @@protoc_insertion_point(field_add:Lazysplits.Proto.TargetInfo.watches)
  return watches_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::TargetInfo_WatchEntry >&
TargetInfo::watches() const {
  // @@protoc_insertion_point(field_list:Lazysplits.Proto.TargetInfo.watches)
  return watches_;
}

// -------------------------------------------------------------------

// WatchInfo_WatchArea

// .Lazysplits.Proto.UScalar2d loc = 1;
inline bool WatchInfo_WatchArea::has_loc() const {
  return this != internal_default_instance() && loc_ != NULL;
}
inline void WatchInfo_WatchArea::clear_loc() {
  if (GetArenaNoVirtual() == NULL && loc_ != NULL) {
    delete loc_;
  }
  loc_ = NULL;
}
inline const ::Lazysplits::Proto::UScalar2d& WatchInfo_WatchArea::_internal_loc() const {
  return *loc_;
}
inline const ::Lazysplits::Proto::UScalar2d& WatchInfo_WatchArea::loc() const {
  const ::Lazysplits::Proto::UScalar2d* p = loc_;
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.WatchArea.loc)
  return p != NULL ? *p : *reinterpret_cast<const ::Lazysplits::Proto::UScalar2d*>(
      &::Lazysplits::Proto::_UScalar2d_default_instance_);
}
inline ::Lazysplits::Proto::UScalar2d* WatchInfo_WatchArea::release_loc() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.WatchInfo.WatchArea.loc)
  
  ::Lazysplits::Proto::UScalar2d* temp = loc_;
  loc_ = NULL;
  return temp;
}
inline ::Lazysplits::Proto::UScalar2d* WatchInfo_WatchArea::mutable_loc() {
  
  if (loc_ == NULL) {
    auto* p = CreateMaybeMessage<::Lazysplits::Proto::UScalar2d>(GetArenaNoVirtual());
    loc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.WatchInfo.WatchArea.loc)
  return loc_;
}
inline void WatchInfo_WatchArea::set_allocated_loc(::Lazysplits::Proto::UScalar2d* loc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete loc_;
  }
  if (loc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      loc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, loc, submessage_arena);
    }
    
  } else {
    
  }
  loc_ = loc;
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.WatchInfo.WatchArea.loc)
}

// .Lazysplits.Proto.UScalar2d size = 2;
inline bool WatchInfo_WatchArea::has_size() const {
  return this != internal_default_instance() && size_ != NULL;
}
inline void WatchInfo_WatchArea::clear_size() {
  if (GetArenaNoVirtual() == NULL && size_ != NULL) {
    delete size_;
  }
  size_ = NULL;
}
inline const ::Lazysplits::Proto::UScalar2d& WatchInfo_WatchArea::_internal_size() const {
  return *size_;
}
inline const ::Lazysplits::Proto::UScalar2d& WatchInfo_WatchArea::size() const {
  const ::Lazysplits::Proto::UScalar2d* p = size_;
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.WatchArea.size)
  return p != NULL ? *p : *reinterpret_cast<const ::Lazysplits::Proto::UScalar2d*>(
      &::Lazysplits::Proto::_UScalar2d_default_instance_);
}
inline ::Lazysplits::Proto::UScalar2d* WatchInfo_WatchArea::release_size() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.WatchInfo.WatchArea.size)
  
  ::Lazysplits::Proto::UScalar2d* temp = size_;
  size_ = NULL;
  return temp;
}
inline ::Lazysplits::Proto::UScalar2d* WatchInfo_WatchArea::mutable_size() {
  
  if (size_ == NULL) {
    auto* p = CreateMaybeMessage<::Lazysplits::Proto::UScalar2d>(GetArenaNoVirtual());
    size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.WatchInfo.WatchArea.size)
  return size_;
}
inline void WatchInfo_WatchArea::set_allocated_size(::Lazysplits::Proto::UScalar2d* size) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete size_;
  }
  if (size) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      size = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.WatchInfo.WatchArea.size)
}

// -------------------------------------------------------------------

// WatchInfo_CharacterEntry

// uint32 character_index = 1;
inline void WatchInfo_CharacterEntry::clear_character_index() {
  character_index_ = 0u;
}
inline ::google::protobuf::uint32 WatchInfo_CharacterEntry::character_index() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.CharacterEntry.character_index)
  return character_index_;
}
inline void WatchInfo_CharacterEntry::set_character_index(::google::protobuf::uint32 value) {
  
  character_index_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.WatchInfo.CharacterEntry.character_index)
}

// string character_val = 2;
inline void WatchInfo_CharacterEntry::clear_character_val() {
  character_val_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WatchInfo_CharacterEntry::character_val() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.CharacterEntry.character_val)
  return character_val_.GetNoArena();
}
inline void WatchInfo_CharacterEntry::set_character_val(const ::std::string& value) {
  
  character_val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.WatchInfo.CharacterEntry.character_val)
}
#if LANG_CXX11
inline void WatchInfo_CharacterEntry::set_character_val(::std::string&& value) {
  
  character_val_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.WatchInfo.CharacterEntry.character_val)
}
#endif
inline void WatchInfo_CharacterEntry::set_character_val(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  character_val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.WatchInfo.CharacterEntry.character_val)
}
inline void WatchInfo_CharacterEntry::set_character_val(const char* value, size_t size) {
  
  character_val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.WatchInfo.CharacterEntry.character_val)
}
inline ::std::string* WatchInfo_CharacterEntry::mutable_character_val() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.WatchInfo.CharacterEntry.character_val)
  return character_val_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WatchInfo_CharacterEntry::release_character_val() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.WatchInfo.CharacterEntry.character_val)
  
  return character_val_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WatchInfo_CharacterEntry::set_allocated_character_val(::std::string* character_val) {
  if (character_val != NULL) {
    
  } else {
    
  }
  character_val_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), character_val);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.WatchInfo.CharacterEntry.character_val)
}

// sint32 x_padding = 3;
inline void WatchInfo_CharacterEntry::clear_x_padding() {
  x_padding_ = 0;
}
inline ::google::protobuf::int32 WatchInfo_CharacterEntry::x_padding() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.CharacterEntry.x_padding)
  return x_padding_;
}
inline void WatchInfo_CharacterEntry::set_x_padding(::google::protobuf::int32 value) {
  
  x_padding_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.WatchInfo.CharacterEntry.x_padding)
}

// sint32 y_padding = 4;
inline void WatchInfo_CharacterEntry::clear_y_padding() {
  y_padding_ = 0;
}
inline ::google::protobuf::int32 WatchInfo_CharacterEntry::y_padding() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.CharacterEntry.y_padding)
  return y_padding_;
}
inline void WatchInfo_CharacterEntry::set_y_padding(::google::protobuf::int32 value) {
  
  y_padding_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.WatchInfo.CharacterEntry.y_padding)
}

// -------------------------------------------------------------------

// WatchInfo_AdditionalOffsetEntry

// uint32 character_length_threshold = 1;
inline void WatchInfo_AdditionalOffsetEntry::clear_character_length_threshold() {
  character_length_threshold_ = 0u;
}
inline ::google::protobuf::uint32 WatchInfo_AdditionalOffsetEntry::character_length_threshold() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.AdditionalOffsetEntry.character_length_threshold)
  return character_length_threshold_;
}
inline void WatchInfo_AdditionalOffsetEntry::set_character_length_threshold(::google::protobuf::uint32 value) {
  
  character_length_threshold_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.WatchInfo.AdditionalOffsetEntry.character_length_threshold)
}

// .Lazysplits.Proto.UScalar2d offset = 2;
inline bool WatchInfo_AdditionalOffsetEntry::has_offset() const {
  return this != internal_default_instance() && offset_ != NULL;
}
inline void WatchInfo_AdditionalOffsetEntry::clear_offset() {
  if (GetArenaNoVirtual() == NULL && offset_ != NULL) {
    delete offset_;
  }
  offset_ = NULL;
}
inline const ::Lazysplits::Proto::UScalar2d& WatchInfo_AdditionalOffsetEntry::_internal_offset() const {
  return *offset_;
}
inline const ::Lazysplits::Proto::UScalar2d& WatchInfo_AdditionalOffsetEntry::offset() const {
  const ::Lazysplits::Proto::UScalar2d* p = offset_;
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.AdditionalOffsetEntry.offset)
  return p != NULL ? *p : *reinterpret_cast<const ::Lazysplits::Proto::UScalar2d*>(
      &::Lazysplits::Proto::_UScalar2d_default_instance_);
}
inline ::Lazysplits::Proto::UScalar2d* WatchInfo_AdditionalOffsetEntry::release_offset() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.WatchInfo.AdditionalOffsetEntry.offset)
  
  ::Lazysplits::Proto::UScalar2d* temp = offset_;
  offset_ = NULL;
  return temp;
}
inline ::Lazysplits::Proto::UScalar2d* WatchInfo_AdditionalOffsetEntry::mutable_offset() {
  
  if (offset_ == NULL) {
    auto* p = CreateMaybeMessage<::Lazysplits::Proto::UScalar2d>(GetArenaNoVirtual());
    offset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.WatchInfo.AdditionalOffsetEntry.offset)
  return offset_;
}
inline void WatchInfo_AdditionalOffsetEntry::set_allocated_offset(::Lazysplits::Proto::UScalar2d* offset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete offset_;
  }
  if (offset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      offset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, offset, submessage_arena);
    }
    
  } else {
    
  }
  offset_ = offset;
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.WatchInfo.AdditionalOffsetEntry.offset)
}

// -------------------------------------------------------------------

// WatchInfo

// string name = 1;
inline void WatchInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WatchInfo::name() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.name)
  return name_.GetNoArena();
}
inline void WatchInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.WatchInfo.name)
}
#if LANG_CXX11
inline void WatchInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.WatchInfo.name)
}
#endif
inline void WatchInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.WatchInfo.name)
}
inline void WatchInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.WatchInfo.name)
}
inline ::std::string* WatchInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.WatchInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WatchInfo::release_name() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.WatchInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WatchInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.WatchInfo.name)
}

// .Lazysplits.Proto.WatchType type = 2;
inline void WatchInfo::clear_type() {
  type_ = 0;
}
inline ::Lazysplits::Proto::WatchType WatchInfo::type() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.type)
  return static_cast< ::Lazysplits::Proto::WatchType >(type_);
}
inline void WatchInfo::set_type(::Lazysplits::Proto::WatchType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.WatchInfo.type)
}

// .Lazysplits.Proto.UScalar2d base_dimensions = 3;
inline bool WatchInfo::has_base_dimensions() const {
  return this != internal_default_instance() && base_dimensions_ != NULL;
}
inline void WatchInfo::clear_base_dimensions() {
  if (GetArenaNoVirtual() == NULL && base_dimensions_ != NULL) {
    delete base_dimensions_;
  }
  base_dimensions_ = NULL;
}
inline const ::Lazysplits::Proto::UScalar2d& WatchInfo::_internal_base_dimensions() const {
  return *base_dimensions_;
}
inline const ::Lazysplits::Proto::UScalar2d& WatchInfo::base_dimensions() const {
  const ::Lazysplits::Proto::UScalar2d* p = base_dimensions_;
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.base_dimensions)
  return p != NULL ? *p : *reinterpret_cast<const ::Lazysplits::Proto::UScalar2d*>(
      &::Lazysplits::Proto::_UScalar2d_default_instance_);
}
inline ::Lazysplits::Proto::UScalar2d* WatchInfo::release_base_dimensions() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.WatchInfo.base_dimensions)
  
  ::Lazysplits::Proto::UScalar2d* temp = base_dimensions_;
  base_dimensions_ = NULL;
  return temp;
}
inline ::Lazysplits::Proto::UScalar2d* WatchInfo::mutable_base_dimensions() {
  
  if (base_dimensions_ == NULL) {
    auto* p = CreateMaybeMessage<::Lazysplits::Proto::UScalar2d>(GetArenaNoVirtual());
    base_dimensions_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.WatchInfo.base_dimensions)
  return base_dimensions_;
}
inline void WatchInfo::set_allocated_base_dimensions(::Lazysplits::Proto::UScalar2d* base_dimensions) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete base_dimensions_;
  }
  if (base_dimensions) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      base_dimensions = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, base_dimensions, submessage_arena);
    }
    
  } else {
    
  }
  base_dimensions_ = base_dimensions;
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.WatchInfo.base_dimensions)
}

// .Lazysplits.Proto.WatchInfo.WatchArea area = 4;
inline bool WatchInfo::has_area() const {
  return this != internal_default_instance() && area_ != NULL;
}
inline void WatchInfo::clear_area() {
  if (GetArenaNoVirtual() == NULL && area_ != NULL) {
    delete area_;
  }
  area_ = NULL;
}
inline const ::Lazysplits::Proto::WatchInfo_WatchArea& WatchInfo::_internal_area() const {
  return *area_;
}
inline const ::Lazysplits::Proto::WatchInfo_WatchArea& WatchInfo::area() const {
  const ::Lazysplits::Proto::WatchInfo_WatchArea* p = area_;
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.area)
  return p != NULL ? *p : *reinterpret_cast<const ::Lazysplits::Proto::WatchInfo_WatchArea*>(
      &::Lazysplits::Proto::_WatchInfo_WatchArea_default_instance_);
}
inline ::Lazysplits::Proto::WatchInfo_WatchArea* WatchInfo::release_area() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.WatchInfo.area)
  
  ::Lazysplits::Proto::WatchInfo_WatchArea* temp = area_;
  area_ = NULL;
  return temp;
}
inline ::Lazysplits::Proto::WatchInfo_WatchArea* WatchInfo::mutable_area() {
  
  if (area_ == NULL) {
    auto* p = CreateMaybeMessage<::Lazysplits::Proto::WatchInfo_WatchArea>(GetArenaNoVirtual());
    area_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.WatchInfo.area)
  return area_;
}
inline void WatchInfo::set_allocated_area(::Lazysplits::Proto::WatchInfo_WatchArea* area) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete area_;
  }
  if (area) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      area = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, area, submessage_arena);
    }
    
  } else {
    
  }
  area_ = area;
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.WatchInfo.area)
}

// uint32 additional_area_padding = 11;
inline void WatchInfo::clear_additional_area_padding() {
  additional_area_padding_ = 0u;
}
inline ::google::protobuf::uint32 WatchInfo::additional_area_padding() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.additional_area_padding)
  return additional_area_padding_;
}
inline void WatchInfo::set_additional_area_padding(::google::protobuf::uint32 value) {
  
  additional_area_padding_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.WatchInfo.additional_area_padding)
}

// float base_threshold = 12;
inline void WatchInfo::clear_base_threshold() {
  base_threshold_ = 0;
}
inline float WatchInfo::base_threshold() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.base_threshold)
  return base_threshold_;
}
inline void WatchInfo::set_base_threshold(float value) {
  
  base_threshold_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.WatchInfo.base_threshold)
}

// .Lazysplits.Proto.RGBColor color = 5;
inline bool WatchInfo::has_color() const {
  return this != internal_default_instance() && color_ != NULL;
}
inline void WatchInfo::clear_color() {
  if (GetArenaNoVirtual() == NULL && color_ != NULL) {
    delete color_;
  }
  color_ = NULL;
}
inline const ::Lazysplits::Proto::RGBColor& WatchInfo::_internal_color() const {
  return *color_;
}
inline const ::Lazysplits::Proto::RGBColor& WatchInfo::color() const {
  const ::Lazysplits::Proto::RGBColor* p = color_;
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.color)
  return p != NULL ? *p : *reinterpret_cast<const ::Lazysplits::Proto::RGBColor*>(
      &::Lazysplits::Proto::_RGBColor_default_instance_);
}
inline ::Lazysplits::Proto::RGBColor* WatchInfo::release_color() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.WatchInfo.color)
  
  ::Lazysplits::Proto::RGBColor* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::Lazysplits::Proto::RGBColor* WatchInfo::mutable_color() {
  
  if (color_ == NULL) {
    auto* p = CreateMaybeMessage<::Lazysplits::Proto::RGBColor>(GetArenaNoVirtual());
    color_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.WatchInfo.color)
  return color_;
}
inline void WatchInfo::set_allocated_color(::Lazysplits::Proto::RGBColor* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete color_;
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.WatchInfo.color)
}

// string img_relative_path = 6;
inline void WatchInfo::clear_img_relative_path() {
  img_relative_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WatchInfo::img_relative_path() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.img_relative_path)
  return img_relative_path_.GetNoArena();
}
inline void WatchInfo::set_img_relative_path(const ::std::string& value) {
  
  img_relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.WatchInfo.img_relative_path)
}
#if LANG_CXX11
inline void WatchInfo::set_img_relative_path(::std::string&& value) {
  
  img_relative_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Lazysplits.Proto.WatchInfo.img_relative_path)
}
#endif
inline void WatchInfo::set_img_relative_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  img_relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lazysplits.Proto.WatchInfo.img_relative_path)
}
inline void WatchInfo::set_img_relative_path(const char* value, size_t size) {
  
  img_relative_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lazysplits.Proto.WatchInfo.img_relative_path)
}
inline ::std::string* WatchInfo::mutable_img_relative_path() {
  
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.WatchInfo.img_relative_path)
  return img_relative_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WatchInfo::release_img_relative_path() {
  // @@protoc_insertion_point(field_release:Lazysplits.Proto.WatchInfo.img_relative_path)
  
  return img_relative_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WatchInfo::set_allocated_img_relative_path(::std::string* img_relative_path) {
  if (img_relative_path != NULL) {
    
  } else {
    
  }
  img_relative_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), img_relative_path);
  // @@protoc_insertion_point(field_set_allocated:Lazysplits.Proto.WatchInfo.img_relative_path)
}

// .Lazysplits.Proto.CharacterJustify character_justify = 7;
inline void WatchInfo::clear_character_justify() {
  character_justify_ = 0;
}
inline ::Lazysplits::Proto::CharacterJustify WatchInfo::character_justify() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.character_justify)
  return static_cast< ::Lazysplits::Proto::CharacterJustify >(character_justify_);
}
inline void WatchInfo::set_character_justify(::Lazysplits::Proto::CharacterJustify value) {
  
  character_justify_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.WatchInfo.character_justify)
}

// .Lazysplits.Proto.CharacterZOrder character_z_order = 8;
inline void WatchInfo::clear_character_z_order() {
  character_z_order_ = 0;
}
inline ::Lazysplits::Proto::CharacterZOrder WatchInfo::character_z_order() const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.character_z_order)
  return static_cast< ::Lazysplits::Proto::CharacterZOrder >(character_z_order_);
}
inline void WatchInfo::set_character_z_order(::Lazysplits::Proto::CharacterZOrder value) {
  
  character_z_order_ = value;
  // @@protoc_insertion_point(field_set:Lazysplits.Proto.WatchInfo.character_z_order)
}

// repeated .Lazysplits.Proto.WatchInfo.CharacterEntry characters = 9;
inline int WatchInfo::characters_size() const {
  return characters_.size();
}
inline void WatchInfo::clear_characters() {
  characters_.Clear();
}
inline ::Lazysplits::Proto::WatchInfo_CharacterEntry* WatchInfo::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.WatchInfo.characters)
  return characters_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::WatchInfo_CharacterEntry >*
WatchInfo::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:Lazysplits.Proto.WatchInfo.characters)
  return &characters_;
}
inline const ::Lazysplits::Proto::WatchInfo_CharacterEntry& WatchInfo::characters(int index) const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.characters)
  return characters_.Get(index);
}
inline ::Lazysplits::Proto::WatchInfo_CharacterEntry* WatchInfo::add_characters() {
  // @@protoc_insertion_point(field_add:Lazysplits.Proto.WatchInfo.characters)
  return characters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::WatchInfo_CharacterEntry >&
WatchInfo::characters() const {
  // @@protoc_insertion_point(field_list:Lazysplits.Proto.WatchInfo.characters)
  return characters_;
}

// repeated .Lazysplits.Proto.WatchInfo.AdditionalOffsetEntry additional_offset = 10;
inline int WatchInfo::additional_offset_size() const {
  return additional_offset_.size();
}
inline void WatchInfo::clear_additional_offset() {
  additional_offset_.Clear();
}
inline ::Lazysplits::Proto::WatchInfo_AdditionalOffsetEntry* WatchInfo::mutable_additional_offset(int index) {
  // @@protoc_insertion_point(field_mutable:Lazysplits.Proto.WatchInfo.additional_offset)
  return additional_offset_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::WatchInfo_AdditionalOffsetEntry >*
WatchInfo::mutable_additional_offset() {
  // @@protoc_insertion_point(field_mutable_list:Lazysplits.Proto.WatchInfo.additional_offset)
  return &additional_offset_;
}
inline const ::Lazysplits::Proto::WatchInfo_AdditionalOffsetEntry& WatchInfo::additional_offset(int index) const {
  // @@protoc_insertion_point(field_get:Lazysplits.Proto.WatchInfo.additional_offset)
  return additional_offset_.Get(index);
}
inline ::Lazysplits::Proto::WatchInfo_AdditionalOffsetEntry* WatchInfo::add_additional_offset() {
  // @@protoc_insertion_point(field_add:Lazysplits.Proto.WatchInfo.additional_offset)
  return additional_offset_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lazysplits::Proto::WatchInfo_AdditionalOffsetEntry >&
WatchInfo::additional_offset() const {
  // @@protoc_insertion_point(field_list:Lazysplits.Proto.WatchInfo.additional_offset)
  return additional_offset_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto
}  // namespace Lazysplits

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Lazysplits::Proto::TargetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Lazysplits::Proto::TargetType>() {
  return ::Lazysplits::Proto::TargetType_descriptor();
}
template <> struct is_proto_enum< ::Lazysplits::Proto::WatchType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Lazysplits::Proto::WatchType>() {
  return ::Lazysplits::Proto::WatchType_descriptor();
}
template <> struct is_proto_enum< ::Lazysplits::Proto::CharacterJustify> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Lazysplits::Proto::CharacterJustify>() {
  return ::Lazysplits::Proto::CharacterJustify_descriptor();
}
template <> struct is_proto_enum< ::Lazysplits::Proto::CharacterZOrder> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Lazysplits::Proto::CharacterZOrder>() {
  return ::Lazysplits::Proto::CharacterZOrder_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_LzsCvDataProtoCpp_2eproto
